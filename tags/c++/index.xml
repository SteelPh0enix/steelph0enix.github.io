<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c++ on SteelPh0enix's Blog</title><link>https://steelph0enix.github.io/tags/c++/</link><description>Recent content in c++ on SteelPh0enix's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Sep 2021 23:35:10 +0200</lastBuildDate><atom:link href="https://steelph0enix.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>VSCode CubeMX Project Setup</title><link>https://steelph0enix.github.io/posts/vscode-cubemx-setup/</link><pubDate>Thu, 16 Sep 2021 23:35:10 +0200</pubDate><guid>https://steelph0enix.github.io/posts/vscode-cubemx-setup/</guid><description>Up until now, i&amp;rsquo;ve used STM32CubeIDE with STM32CubeMX as my primary development tools for STM32 microcontrollers. CubeIDE has lots of useful features available out-of-the-box. However, it also suffers from pretty feelable bloat, caused by the fact that it&amp;rsquo;s heavily modified Eclipse IDE with lots of plugins that pile up pretty quickly. It also lacks some features that i&amp;rsquo;m used to having in more&amp;hellip; &amp;ldquo;civilized&amp;rdquo; IDE&amp;rsquo;s (dark theme which is not hurting the eyes with contrast by default?</description><content>&lt;p>Up until now, i&amp;rsquo;ve used STM32CubeIDE with STM32CubeMX as my primary development tools for STM32 microcontrollers. CubeIDE has lots of useful features available out-of-the-box. However, it also suffers from pretty feelable bloat, caused by the fact that it&amp;rsquo;s heavily modified Eclipse IDE with lots of plugins that pile up pretty quickly. It also lacks some features that i&amp;rsquo;m used to having in more&amp;hellip; &amp;ldquo;civilized&amp;rdquo; IDE&amp;rsquo;s (dark theme which is not hurting the eyes with contrast by default? better Git integration? and probably lots of other, smaller thingies). So, i&amp;rsquo;ve decided to try something new and the first obvious choice was Visual Studio Code.&lt;/p>
&lt;blockquote>
&lt;p>The second choice would be CLion, which has pretty decent CubeMX project support out-of-the-box, but it is sometimes a little bit buggy with debugging the projects&amp;hellip; or at least it was few months ago, when i tried it. Maybe it got fixed.&lt;/p>
&lt;/blockquote>
&lt;p>So, after few hours of tinkering and lurking around for guides and plugins, i&amp;rsquo;ve found my setup. Most of the config i&amp;rsquo;ve taken from two great videos by &lt;a href="https://www.youtube.com/channel/UCuigr_BEzX1g3Qvwq5QjPXg">Embedded Geek&lt;/a> (first one is &lt;a href="https://www.youtube.com/watch?v=PxQw5_7yI8Q">here&lt;/a>, second one - &lt;a href="https://www.youtube.com/watch?v=xaC5oWwzOt0">here&lt;/a>), but i&amp;rsquo;ve changed some things since i&amp;rsquo;m not using the exact same VSCode config as he does (which, actually, makes things easier and less painful to configure for me). I also made sure that it should work on both Windows and Linux (and &lt;em>probably&lt;/em> MacOS).&lt;/p>
&lt;blockquote>
&lt;p>If you are very lazy, you can use &lt;a href="https://marketplace.visualstudio.com/items?itemName=bmd.stm32-for-vscode">&lt;code>stm32-for-vscode&lt;/code>&lt;/a> plugin instead of this guide. It should do most of the work described there automatically. However, it uses default IntelliSense engine, and as i prefer clangd and knowing how to configure the project from scratch (so when something goes wrong, i know how to fix it), i still created this guide. &lt;em>I&amp;rsquo;ve used it in the past, but after trying it again and comparing with setup made using this guide i found out it doesn&amp;rsquo;t offer better experience in the long run&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>Anyway, let&amp;rsquo;s get to it.&lt;/p>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>From hardware side, you need to have an STM32 board, and a debugger that&amp;rsquo;s compatible with it. For this guide, i&amp;rsquo;m using Nucleo-G474RE, with STM32G474RET6 microcontroller, and STLink v3 onboard. The exact choice of MCU and debugger doesn&amp;rsquo;t matter, as this setup will work with any STM32 MCU and every debugger supported by OpenOCD. Also, you&amp;rsquo;ll need an USB cable to connect the board to your PC.
&lt;strong>If you&amp;rsquo;re using ST-Link, update it&amp;rsquo;s firmware before proceeding. You can do it with &lt;a href="https://www.st.com/en/development-tools/stsw-link007.html">this official tool&lt;/a>&lt;/strong>. Free ST account is required to download it.&lt;/p>
&lt;p>From software side, these tools are required:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.st.com/en/development-tools/stm32cubemx.html">&lt;strong>STM32CubeMX&lt;/strong>&lt;/a> - STM32 MCU helper and code generator, simplifies the project generation and MCU initialization to maximum - downloadable for free from official ST site &lt;a href="https://www.st.com/en/development-tools/stm32cubemx.html">here&lt;/a>. Requires free ST account to download. &lt;em>PSA for HAL-haters: you don&amp;rsquo;t have to use HAL even if you generate the code using CubeMX - read about LL libraries, you can use them too, and they are as close to the metal as it&amp;rsquo;s sanely possible. I&amp;rsquo;ll put a quick info about it at the end of this guide, as a bonus.&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">&lt;strong>ARM-GCC toolchain&lt;/strong>&lt;/a> (&lt;code>arm-none-eabi-gcc&lt;/code> to be specific, along with all the other GCC tools, and GDB). Linux users should have latest version in the repositories - make sure you also install &lt;code>arm-none-eabi-newlib&lt;/code> and &lt;code>arm-none-eabi-binutils&lt;/code> if these are separate packages. Windows users can either use their preferred package manager, or download the latest toolchain manually from &lt;a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">official ARM site&lt;/a> - MacOS and Linux versions are available there too, in case you don&amp;rsquo;t have one in repositories. &lt;strong>Just make sure it&amp;rsquo;s in your OS PATH variable before proceeding - open terminal and try running &lt;code>arm-none-eabi-gcc --version&lt;/code>. If it fails, add the toolchain&amp;rsquo;s &lt;code>bin&lt;/code> directory to PATH.&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://openocd.org/pages/getting-openocd.html">&lt;strong>OpenOCD&lt;/strong>&lt;/a> - we&amp;rsquo;ll use it to debug and flash the firmware on our microcontroller. Get it from your package manager, or via one of the unofficial distributions listed &lt;a href="https://openocd.org/pages/getting-openocd.html">here&lt;/a>. Or you can also build it from source, which is fairly easy. &lt;strong>Make sure it&amp;rsquo;s in PATH too - check if &lt;code>openocd --version&lt;/code> prints the info, if not - add the directory with it&amp;rsquo;s executable to PATH.&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://code.visualstudio.com/">&lt;strong>Visual Studio Code&lt;/strong>&lt;/a> - obviously. If you are new to this editor, i strongly suggest to check out &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/">my previous guide&lt;/a> about configuring it for C/C++ projects with CMake. We won&amp;rsquo;t use CMake here (although it is possible to do that with a little bit of help from &lt;a href="https://github.com/ObKo/stm32-cmake">&lt;code>stm32-cmake&lt;/code>&lt;/a> repository), but i will use &lt;code>clangd&lt;/code>, as i prefer this language server over the default one, and it&amp;rsquo;s easier to set-up. So, if you want to stay with default language server, keep in mind that you will have to configure include paths manually, which is painful and i won&amp;rsquo;t describe it here. &lt;em>If you have no idea what i&amp;rsquo;m writing about here - just follow this guide and install all the plugins listed below&lt;/em>. I strongly recommend to use these plugins for VSCode:
&lt;ul>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">&lt;strong>C/C++&lt;/strong>&lt;/a> - for general C and C++ language support - &lt;strong>required&lt;/strong>;&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">&lt;strong>Cortex-Debug&lt;/strong>&lt;/a> - for ARM Cortex-M debugging - &lt;strong>required&lt;/strong>;&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">&lt;strong>clangd&lt;/strong>&lt;/a> - alternative language server that usually works better than default one, and has easier and more robust config. Also features configurable code auto-formatting. If you don&amp;rsquo;t know what language server does, or you haven&amp;rsquo;t played with default one yet - install and use &lt;code>clangd&lt;/code>, you can find basic setup instructions &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#bonus-clangd-setup">here&lt;/a>, and i&amp;rsquo;ll guide you through configuration for this project. If you know what you&amp;rsquo;re doing - have fun.&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=dan-c-underwood.arm">&lt;strong>ARM&lt;/strong>&lt;/a> - for ARM assembly language support. Useful when lurking around *.s files - optional;&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=ZixuanWang.linkerscript">&lt;strong>LinkerScript&lt;/strong>&lt;/a> - for linker script language support. Useful when lurking around *.ld files - optional;&lt;/li>
&lt;li>And also plugins from my list of recommended C/C++ plugins, which you can find &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#vscode-essential-plugins">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.st.com/en/development-tools/stsw-link009.html">&lt;strong>ST-Link (or your preferred debugger) drivers&lt;/strong>&lt;/a> - if you already have &lt;a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE&lt;/a> or &lt;a href="https://www.st.com/en/development-tools/stm32cubeprog.html">STM32CubeProgrammer&lt;/a> installed on your system, you should already have them. If that&amp;rsquo;s not the case, then either install STM32CubeProgrammer to get all the drivers that you&amp;rsquo;d need for most STM32-compatible debuggers, or download and install the drivers for your specific debugger and OS manually. &lt;strong>Just make sure that your debugger is detected correctly by your operating system before proceeding&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>And that should be just about it. If you have everything set-up, can get to work on our project.&lt;/p>
&lt;h2 id="creating-a-project">Creating a project&lt;/h2>
&lt;p>Open up STM32CubeMX and make a new project. I&amp;rsquo;ll assume that you already have basic knowledge of STM32CubeMX usage, so you can create a project for your board. After that, set up your peripherals (i&amp;rsquo;ll just use onboard LED which is set up by default to test stuff out), make sure the debug is enabled (System Core -&amp;gt; SYS -&amp;gt; Debug), clocks are configured correctly (Clock Configuration tab on the top of the window), and go to Project Manager tab. Fill up the project name and location, and set &lt;strong>Toolchain/IDE&lt;/strong> to &lt;strong>Makefile&lt;/strong>. Save the project after that.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/cubemx-config-1.png" alt="cubemx-project-config-1">&lt;/p>
&lt;p>Next, i recommend going to &lt;strong>Code Generator&lt;/strong> tab on the left and selecting all the checkboxes in &lt;strong>Generated files&lt;/strong> section. I do it as force of habit, to have a bit better organized project.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/cubemx-config-2.png" alt="cubemx-project-config-2">&lt;/p>
&lt;p>When you&amp;rsquo;re done with CubeMX config, &lt;strong>Generate the code&lt;/strong> and open the directory with the project in Visual Studio Code.&lt;/p>
&lt;h2 id="setting-up-the-project-in-vscode">Setting up the project in VSCode&lt;/h2>
&lt;h3 id="building-the-project">Building the project&lt;/h3>
&lt;p>Now, time for the fun part. First, we&amp;rsquo;ll make sure we can build the project. Open integrated terminal (&lt;code>Ctrl+` &lt;/code> to open existing one, or &lt;code>Ctrl+Shift+` &lt;/code> to create a new one) and run &lt;code>make&lt;/code>. You should see some output - the commands ran by Make, and size of output binary - and a new directory called &lt;code>build&lt;/code> should appear. The project directory should look like this now:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/post-build-files-tree.png" alt="post-build-file-tree">&lt;/p>
&lt;blockquote>
&lt;p>If the build failed, read the error message, check if you have all required prerequisites, and look around the internet for support - most of basic issues have been solved by someone already, and solutions are out there.&lt;/p>
&lt;/blockquote>
&lt;p>The &lt;code>build&lt;/code> directory should contain a lot of object (&lt;code>*.o&lt;/code>) , listing (&lt;code>*.lst&lt;/code>), and &lt;code>*.d&lt;/code> files, along with few binaries with the same name as your project, and also a &lt;code>*.map&lt;/code> file, which contains the memory map of whole program.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/post-build-files-out.png" alt="post-build-file-out">&lt;/p>
&lt;p>The only file here that&amp;rsquo;s currently interesting for us is the &lt;code>*.elf&lt;/code> file - this is the actual compiled binary we&amp;rsquo;ll flash to MCU using OpenOCD. &lt;code>*.bin&lt;/code> and &lt;code>*.hex&lt;/code> files are compiled binary files too, created out of the &lt;code>*.elf&lt;/code> file, but they are usually used in different scenarios (for example, &lt;code>*.bin&lt;/code> file can easily be used by custom bootloaders, as it&amp;rsquo;s basically raw compiled code, stripped out of unnecessary stuff).&lt;/p>
&lt;h3 id="configuring-the-language-server-clangd">Configuring the language server (clangd)&lt;/h3>
&lt;p>If you&amp;rsquo;re able to build project successfully, then it&amp;rsquo;s time to set up our language server. Clangd requires &lt;code>compile_commands.json&lt;/code> file to work properly - this file contains translated output from your build system, that tells Clangd how the project is built. Thanks to that, Clangd can automatically detect the configuration you&amp;rsquo;re using and you doesn&amp;rsquo;t have to manually set anything up, unlike in default language server, where you&amp;rsquo;d have to set the include directories, flags and toolchain manually in JSON file.&lt;/p>
&lt;p>There are few ways to generate &lt;code>compile_commands.json&lt;/code>. As i&amp;rsquo;ve described in &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#bonus-clangd-setup">my previous blog post&lt;/a>, CMake generates this file automatically. However, we are not using CMake, so we have to use external tool for that. I&amp;rsquo;ve know of two, that i managed to get working without issues: &lt;a href="https://github.com/rizsotto/Bear">&lt;strong>Bear&lt;/strong>&lt;/a>, which supposedly works only on Linux, but apparently there is a version available in &lt;code>winget&lt;/code> repository, and &lt;a href="https://github.com/nickdiego/compiledb">&lt;strong>compiledb&lt;/strong>&lt;/a> which should work anywhere, and is written in Python, so you need it installed to use it. &lt;strong>Note: install &lt;code>compiledb&lt;/code> IN USER DIRECTORY (&lt;code>python3 -m pip install --user compiledb&lt;/code>), because it may not work when installed globally due to permission issues! If you encounter permission-related issues, make sure all of it&amp;rsquo;s dependencies are installed in user directories too! And make sure it&amp;rsquo;s in your PATH variable! Same goes for Bear.&lt;/strong>&lt;/p>
&lt;p>The usage of these tools is simple: you run them with your build command, so they take it&amp;rsquo;s output and convert it to Clangd&amp;rsquo;s &lt;code>compile_commands.json&lt;/code>. In case of Bear, you also have to make clean-build (run &lt;code>make clean&lt;/code> before running it), which makes it troublesome to integrate with our setup, so i&amp;rsquo;m going to use &lt;code>compiledb&lt;/code> here.&lt;/p>
&lt;p>To build the project and generate the &lt;code>compile_commands.json&lt;/code>, run &lt;code>compiledb make -j8&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Tip: You can tell &lt;code>make&lt;/code> to build using multiple threads with &lt;code>-j&lt;/code> argument. This will &lt;strong>significantly&lt;/strong> decrease compilation time. For example: &lt;code>make -j8&lt;/code> will build the program using 8 threads. Modify this argument according to your CPU capabilities (amount of cores and thread per core).&lt;/p>
&lt;/blockquote>
&lt;p>Compiledb will run &lt;code>make&lt;/code> and pass all the arguments to it, &lt;code>-j8&lt;/code> in our case. After running this command from the project root, the &lt;code>compile_commands.json&lt;/code> should appear there. Open any &lt;code>*.c&lt;/code> or &lt;code>*.h&lt;/code> file, or re-open, if you opened them already, and check if the language server works - you should now see no errors related to missing includes or unrecognized function, see the tooltips for code on hover, and have all the other language-server-related features working.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/clangd-working.png" alt="clangd-working">&lt;/p>
&lt;h4 id="configuring-standard-library-visibility">Configuring standard library visibility&lt;/h4>
&lt;p>After playing with &lt;code>clangd&lt;/code> a bit more in this project, i found out that even though project builds successfully when i use standard library, clangd doesn&amp;rsquo;t recognize it&amp;rsquo;s headers for some reason. I suppose it&amp;rsquo;s because the target platform is not the native one, so it doesn&amp;rsquo;t know where to look for headers. I&amp;rsquo;ve fixed it by adding include path with stdlib headers to &lt;code>C_INCLUDES&lt;/code> variable in Makefile, and clean-building the project.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># C includes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>C_INCLUDES &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-ICore/Inc &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/STM32G4xx_HAL_Driver/Inc &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/STM32G4xx_HAL_Driver/Inc/Legacy &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/CMSIS/Device/ST/STM32G4xx/Include &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/CMSIS/Include &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-I/usr/arm-none-eabi/include&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="flashing-the-binary">Flashing the binary&lt;/h3>
&lt;p>We&amp;rsquo;ll create a rule in Makefile to flash our program to MCU. You could do this as VSCode task too, if you&amp;rsquo;d like, with slight modifications.
Open the &lt;code>Makefile&lt;/code>, and somewhere on the bottom, before EOF marker, add a new rule that will run OpenOCD:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">flash&lt;/span>&lt;span style="color:#f92672">:&lt;/span> all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openocd -f interface/stlink.cfg -f target/stm32g4x.cfg -c &lt;span style="color:#e6db74">&amp;#34;program &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>BUILD_DIR&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>TARGET&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">.elf verify reset exit&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>If you are not using ST-Link, change the interface config file to proper one. Same applies to MCU config file - switch it to one that&amp;rsquo;s for MCU you&amp;rsquo;re working on.&lt;/strong> All the configuration files are stored in OpenOCD installation directory. If you&amp;rsquo;re on Linux, they should be stored in &lt;code>/usr/share/openocd/&lt;/code> by default.
The rest of this command tells OpenOCD what to do - program the specific ELF file to MCU flash memory, verify the memory integrity, reset the MCU and exit.
It also requires &lt;code>all&lt;/code> rule, so the project will build itself automatically and upload the ELF file to MCU every time you run &lt;code>make flash&lt;/code> now. &lt;strong>This does NOT dissapear during CubeMX project re-generation, so you don&amp;rsquo;t have to worry about copy&amp;amp;pasting it every time you do this&lt;/strong>.
To delete all the build files (to do a clean build for example), use &lt;code>make clean&lt;/code> command.&lt;/p>
&lt;h3 id="configuring-vscode-tasks">Configuring VSCode tasks&lt;/h3>
&lt;p>To get some degree of automation, we&amp;rsquo;ll create VSCode tasks for building, cleaning and flashing the project. Open command prompt in VSCode (&lt;code>Ctrl+Shift+P&lt;/code>), and look for &lt;code>Tasks: Configure Default Build Task&lt;/code> command (or &lt;code>Task: Configure Task&lt;/code>).&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-1.png" alt="create-build-task-1">&lt;/p>
&lt;p>Then, select &lt;code>Create tasks.json file from template&lt;/code>, and select &lt;code>Others&lt;/code> template.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-2.png" alt="create-build-task-2">
&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-3.png" alt="create-build-task-3">&lt;/p>
&lt;p>After that, you should see this &lt;code>tasks.json&lt;/code> file, which happened to be added to &lt;code>.vscode&lt;/code> directory in project root. If you&amp;rsquo;re using VCS (Git or Mercurial for example), you should be able to store it in repository without any issues, so don&amp;rsquo;t wildcard out the entire &lt;code>.vscode&lt;/code> directory in your &lt;code>.gitignore&lt;/code> (or any other VCS-related ignorefile) to keep the tasks.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-4.png" alt="create-build-task-4">&lt;/p>
&lt;p>Copy this task and modify label and command accordingly, to create a build, clean and flash task. After that, run &lt;code>Tasks: Configure Default Build Task&lt;/code> command again, and select your build task. &lt;strong>Remember that we&amp;rsquo;re using &lt;code>Bear&lt;/code>/&lt;code>compiledb&lt;/code> to generate compilation database for Clangd! Don&amp;rsquo;t call &lt;code>make&lt;/code> for building the project directly, to always have updated and correct database!&lt;/strong> Now, your &lt;code>tasks.json&lt;/code> file should look similar to this (change the thread amount accordingly to your CPU capabilities):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// See https://go.microsoft.com/fwlink/?LinkId=733558
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// for the documentation about the tasks.json format
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tasks&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;label&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Build&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;shell&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;command&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;compiledb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;args&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;make&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;-j8&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;problemMatcher&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;group&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;build&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;isDefault&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;label&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Build &amp;amp; Flash&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;shell&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;command&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;compiledb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;args&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;make&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;flash&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;-j8&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;label&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Clean&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;shell&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;command&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;make&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;args&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;clean&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Test the tasks out by running &lt;code>Clean&lt;/code> task (&lt;code>Tasks: Run Task&lt;/code> command -&amp;gt; select &lt;code>Clean&lt;/code> task -&amp;gt; don&amp;rsquo;t scan the output, if you&amp;rsquo;re asked for that), and using &lt;code>Tasks: Run Build Task&lt;/code> shortcut - &lt;code>Ctrl+Shift+B&lt;/code>. The program should first clean, then build itself, and you should see &lt;code>make&lt;/code> output in integrated console window.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/task-output.png" alt="task-output">&lt;/p>
&lt;p>Make a backup of this &lt;code>tasks.json&lt;/code> file, because it should be exactly the same for every project configured this way.
Also, reminder: instead of putting &lt;code>openocd&lt;/code> call in &lt;code>Makefile&lt;/code>, you can do it directly in VSCode task if you want - just split the arguments correctly (the command after &lt;code>-c&lt;/code> should be a single argument), and set the &lt;code>Build&lt;/code> task as &lt;code>Flash&lt;/code> task dependency &lt;a href="https://code.visualstudio.com/docs/editor/tasks#_compound-tasks">with &lt;code>dependsOn&lt;/code> list option&lt;/a>. You can also create a flash-only task like that. It&amp;rsquo;s up to your preference.&lt;/p>
&lt;h3 id="configuring-the-debugger">Configuring the debugger&lt;/h3>
&lt;p>Time to configure the debugging task. Go to the debug tab, and click on &lt;code>create a launch.json file&lt;/code>. Then, from the list, select &lt;code>Cortex Debug&lt;/code> option.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-task-1.png" alt="debug-task-1">&lt;/p>
&lt;p>You should now have this file created, with default task for Cortex Debug plugin. We&amp;rsquo;ll have to change few things to make it working with OpenOCD, our debugger and MCU.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-task-2.png" alt="debug-task-2">&lt;/p>
&lt;p>First, we&amp;rsquo;ll have to change the path to &lt;code>executable&lt;/code>, so it points to the &lt;code>elf&lt;/code> file with our program, which is in &lt;code>${workspaceRoot}/build/&lt;/code> directory. Then, we have to change &lt;code>servertype&lt;/code> to &lt;code>openocd&lt;/code>. It&amp;rsquo;s not the only debugger that Cortex Debug can use, you can see the whole list by calling autocompletion in empty field. Most of them should work with STM32, but i&amp;rsquo;ll focus on OpenOCD.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-task-3.png" alt="debug-task-3">&lt;/p>
&lt;p>Then, we have to configure some OpenOCD-related stuff. We have to specify &lt;code>device&lt;/code>, and put the microcontroller name in it (without &lt;code>Tx&lt;/code> suffix, which corresponds to the temperature version of chip: for example, i&amp;rsquo;m using &lt;code>STM32G474RET6&lt;/code>, but in &lt;code>device&lt;/code> i have to put only &lt;code>STM32G474RE&lt;/code>, because all the temperature versions have exactly the same silicon inside). We also have to specify the configuration files for OpenOCD - the same ones that we specified for flashing. You can do it via &lt;code>configFiles&lt;/code> list.&lt;/p>
&lt;p>You should also specify &lt;code>preLaunchTask&lt;/code>, so VSCode will &lt;strong>always&lt;/strong> build and flash the binary before starting debug session. It&amp;rsquo;s important, because if you&amp;rsquo;d forget about it and start debugging session with different program on MCU than on your PC, debugger - at some point - will start showing you complete junk and unreasonable code flow, and if you are not aware of that, you will probably spend &lt;strong>a lot&lt;/strong> of time thinking what&amp;rsquo;s wrong with your code or MCU.&lt;/p>
&lt;p>The &lt;code>launch.json&lt;/code> file content should now look like this, except the &lt;code>device&lt;/code> and target config files should conform to MCU and debugger you&amp;rsquo;re using, &lt;code>preLaunchTask&lt;/code> should have the same name as your flash task, and &lt;code>executable&lt;/code> should point to your ELF file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Use IntelliSense to learn about possible attributes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Hover to view descriptions of existing attributes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.2.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;configurations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Cortex Debug&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cwd&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${workspaceRoot}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;executable&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${workspaceRoot}/build/blog-vscode-cubemx-example.elf&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;request&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;launch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cortex-debug&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;servertype&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;openocd&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;device&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;STM32G474RE&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;configFiles&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;interface/stlink.cfg&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;target/stm32g4x.cfg&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;preLaunchTask&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Build &amp;amp; Flash&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If everything has been configured correctly, you should be able to debug your program now. Add a breakpoint in the first line of &lt;code>main&lt;/code> function (click left to line number, red dot should appear) and run the debugging session (&lt;code>F5&lt;/code> by default, or click a button on top of Debug menu).&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-session.png" alt="debug-session">&lt;/p>
&lt;p>VSCode should switch to debug perspective, and you should be able to see variables/objects (expand Global section), call stack, and add variables/objects to the watch. You should also be able to step through the program - either via controls on top, or keyboard shortcuts (&lt;code>F5&lt;/code> to let the program run until the next breakpoint, &lt;code>F10&lt;/code> to step over current line, &lt;code>F11&lt;/code> to step into current line, &lt;code>Shift+F11&lt;/code> to step out of current scope, &lt;code>Ctrl+Shift+F5&lt;/code> to restart debugging session, and &lt;code>Shift+F5&lt;/code> to stop debugging session). There&amp;rsquo;s also a button to reset the MCU (first from left).&lt;/p>
&lt;h4 id="configuring-the-peripheral-view">Configuring the peripheral view&lt;/h4>
&lt;p>Finally, to see all the peripherals of our MCU and their registers content, we can download and specify SVD (or rather, to be precise, CMSIS-SVD - System View Description) file. &lt;strong>This step is optional, but being able to see the peripherals is useful, so i recommend doing this anyway&lt;/strong>. For ST MCU&amp;rsquo;s, you can get SVD files from the MCU page on st.com. For example, in case of my MCU i go &lt;a href="https://www.st.com/en/microcontrollers-microprocessors/stm32g474re.html">here&lt;/a>, into &lt;code>CAD Resources&lt;/code> tab, and i download &lt;code>STM32G4 System view description&lt;/code> (ST account not required).&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/svd-config-1.png" alt="svd-config-1">&lt;/p>
&lt;p>After that, i unpack it. Inside unpacked archive, there should be a directory wih &lt;code>*.svd&lt;/code> files - find one compatible with your MCU (in my case it&amp;rsquo;s named &lt;code>STM32G474xx.svd&lt;/code>) and copy it to project root directory. Now, open &lt;code>launch.json&lt;/code> and add new option in debug configuration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;svdFile&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;${workspaceRoot}/STM32G474xx.svd&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Of course, change the name of the file to correct one. To check if it&amp;rsquo;s working, start debug session (&lt;code>F5&lt;/code>) and look for &lt;code>Cortex Peripherals&lt;/code> section in debug view. Open it and check if you can see the peripherals, along with their addresses, registers and register fields content.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/peripherals-view.png" alt="peripherals-view">&lt;/p>
&lt;p>And that&amp;rsquo;s all. If you did all the steps, and verified they&amp;rsquo;re working, congratulations - you now have an alternative for CubeIDE for STM32 development with CubeMX, that isn&amp;rsquo;t very painful to configure and has most of the features you&amp;rsquo;ll need. I&amp;rsquo;ve heard that Cortex Debug also allows to configure ITM output, but i haven&amp;rsquo;t tried that yet, so i&amp;rsquo;ll probably describe it in different blog post in the future.&lt;/p>
&lt;p>Now, for the bonus part&amp;hellip;&lt;/p>
&lt;h2 id="stm32-hal-vs-ll-libraries-and-how-to-change-between-them-in-cubemx">STM32 HAL vs LL libraries, and how to change between them in CubeMX&lt;/h2>
&lt;p>If you&amp;rsquo;re using CubeMX for STM32 projects, you are (most probably) inherently using HAL libraries to work with the MCU. HAL is an Hardware Abstraction Layer - set of libraries which abstract operations on the hardware, that are easy to use for someone who doesn&amp;rsquo;t want to dig through the manual to do even simplest things. Also worth mentioning, that STM32 HAL is &lt;em>mostly&lt;/em> the same under all STM32 MCUs, therefore moving project that relies on HAL between different STM32 MCUs in the same family, or even between different families of STM32 MCUs, is fairly easy. However, it do have some issues - mainly, the memory bloat that&amp;rsquo;s sometimes really noticable (especially on low-end MCUs with very little memory - some of them even can&amp;rsquo;t use HAL at all, because it takes more memory than they have for simple project with just the initialization code). It can also be slower than dedicated solutions, due to handling almost everything that can happen every time.&lt;/p>
&lt;p>The solution of these issues doesn&amp;rsquo;t have to be throwing away CubeMX, and going back to the registers and CMSIS level, writing everything manually. There is an alternative - Low Layer libraries. These exist for all the peripherals that don&amp;rsquo;t require upper-level stack (like USB or Ethernet), and are significantly lighter than HAL. However, they are also more complicated to use, as they don&amp;rsquo;t cover the functionality as HAL libraries do. LL offers a low-level API that&amp;rsquo;s just above the registers. In other words, LL is an almost unnoticeable (performance and memory-wise) layer that abstracts the registers away, giving you fairly well documented and more readable API instead, that doesn&amp;rsquo;t take away much control from you.&lt;/p>
&lt;p>To learn about HAL and LL differences in detail, i suggest going to CubeMX package site for your STM32 MCU (in my case: &lt;a href="https://www.st.com/en/embedded-software/stm32cubeg4.html">this one&lt;/a>), into &lt;code>Documentation&lt;/code> section, and reading User Manual called &lt;code>Description of STM32XY HAL and low-layer drivers&lt;/code>, where &lt;code>XY&lt;/code> symbolize you series. You can find full documentation of both HAL and LL libraries there, along with their philosophy.&lt;/p>
&lt;p>There is an easy way of changing between HAL and LL drivers in CubeMX: open the project and go to &lt;code>Project Manager -&amp;gt; Advanced Settings&lt;/code>.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cubemx-setup/cubemx-hal-ll.png" alt="cubemx-hal-ll">&lt;/p>
&lt;p>You can do three things there:&lt;/p>
&lt;ul>
&lt;li>Change between HAL and LL drivers for every peripheral, and even every instance of peripheral;&lt;/li>
&lt;li>Configure the initialization order of used peripherals (very useful for issues with DMA, when it&amp;rsquo;s wrongly initialized after the peripheral that&amp;rsquo;s using it);&lt;/li>
&lt;li>Enable or disable callback registration per peripheral (as an alternative to global interrupt callbacks).&lt;/li>
&lt;/ul>
&lt;p>While you still might not want to use LL, it&amp;rsquo;s a good idea to take a look there if you look for memory to free. For example, if you are not using any peripheral-related functions in code, yet you need that peripheral initialized (which can be a case for RCC for example), you can switch it from HAL to LL to save few bytes of memory without touching the code yourself. &lt;strong>But remember: HAL and LL functions ARE NOT inter-compatible. You CANNOT use both HAL and LL for the same peripheral at the same time (without proper precautions), as HAL requires a handle that&amp;rsquo;s state reflects the current state of peripheral. If you start using non-HAL code along with HAL, you HAVE TO make sure the state in HAL handle will not be invalid when HAL functions are being called (in interrupts that use HAL handlers too!), otherwise HAL code can break the program.&lt;/strong>&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>And that would be it. Thank you for reading, and if you have questions or issues, feel free to &lt;a href="https://steelph0enix.github.io/about/">contact me&lt;/a> or drop an issue/pull request in &lt;a href="https://github.com/SteelPh0enix/steelph0enix.github.io">the blog&amp;rsquo;s repository&lt;/a>.&lt;/p></content></item><item><title>Visual Studio Code - C/C++ Setup</title><link>https://steelph0enix.github.io/posts/vscode-cpp-setup/</link><pubDate>Tue, 08 Jun 2021 09:48:53 +0200</pubDate><guid>https://steelph0enix.github.io/posts/vscode-cpp-setup/</guid><description>Visual Studio Code is a great open-source editor with plenty of useful plugins for insane amount of languages and frameworks.
However, as C and C++ environment is pretty janky for today&amp;rsquo;s standards, so is the configuration. So i made this guide to streamline the process and make it easy for somebody new in C, C++ or VSCode to setup a reasonably working dev environment with some useful quality-of-life tools. It might not be IntelliJ-level of quality, but hey - it&amp;rsquo;s free.</description><content>&lt;p>Visual Studio Code is a great open-source editor with plenty of useful plugins for insane amount of languages and frameworks.&lt;/p>
&lt;p>However, as C and C++ environment is pretty janky for today&amp;rsquo;s standards, so is the configuration. So i made this guide to streamline the process and make it easy for somebody new in C, C++ or VSCode to setup a reasonably working dev environment with some useful quality-of-life tools. It might not be IntelliJ-level of quality, but hey - it&amp;rsquo;s free.&lt;/p>
&lt;p>In this guide, i will tell you:&lt;/p>
&lt;ul>
&lt;li>What tools you&amp;rsquo;ll need to start developing C and C++ apps in VSCode&lt;/li>
&lt;li>What extensions you might want to install to ease up the code writing process, and how to configure them&lt;/li>
&lt;li>How do you create a C/C++ project in VSCode (with CMake) and integrate it with VSCode&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;h3 id="vscode">VSCode&lt;/h3>
&lt;p>The obvious prerequisite is Visual Studio Code. Install it from the official site: &lt;a href="https://code.visualstudio.com/">https://code.visualstudio.com/&lt;/a>, or from a repository if you&amp;rsquo;re using a package manager.&lt;/p>
&lt;p>&lt;strong>For Windows&lt;/strong>: either download the installer from official site and run it, or install VSCode via &lt;a href="https://scoop.sh/">scoop&lt;/a>: &lt;code>scoop install vscode&lt;/code>. &lt;em>btw; i strongly recommend &lt;code>scoop&lt;/code> - great package manager&lt;/em>&lt;/p>
&lt;p>&lt;strong>For Linux&lt;/strong>: if you have it in your package manager repository, install it from there. Otherwise, use the installer from official site.&lt;/p>
&lt;p>&lt;strong>For MacOS&lt;/strong>: same as for Linux. Probably. I don&amp;rsquo;t use MacOS so i can&amp;rsquo;t really tell.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Fun fact&lt;/strong>; there are two versions of VSCode you can find on the internet and in package managers - OSS version, and Non-OSS. The OSS version is basically the VSCode you&amp;rsquo;d get by downloading it from &lt;a href="https://github.com/microsoft/vscode">official repository&lt;/a> and building it yourself. Non-OSS version is the one from Microsoft distribution (for example, their official site), and the only difference between them is that Non-OSS version uses some Microsoft propertiary code, while OSS doesn&amp;rsquo;t. There is some functional difference (IIRC, OSS version lacks proprietary features like Settings Sync or Remote WSL/SSH/Containers), but both are fully compatible in terms of plugins and configuration, so you usually don&amp;rsquo;t need to worry about the exact version you&amp;rsquo;ve installed.&lt;/p>
&lt;/blockquote>
&lt;h3 id="cc-toolchain">C/C++ Toolchain&lt;/h3>
&lt;p>There are many C/C++ toolchains available, and i&amp;rsquo;m not gonna enforce one, because this guide is mostly toolchain-independent (in the end we&amp;rsquo;re gonna use build system, but most of the examples are for GCC). However, if you are new to C/C++, i&amp;rsquo;d recommend starting with GCC (or MinGW, if you&amp;rsquo;re on Windows) as it&amp;rsquo;s easy to install and use out of the box.&lt;/p>
&lt;p>If you already have your preferred toolchain installed and configured, feel free to go to the next step. If not, here&amp;rsquo;s the guide:&lt;/p>
&lt;p>&lt;strong>For Windows&lt;/strong>:&lt;/p>
&lt;ul>
&lt;li>Download MinGW-w64 installer from &lt;a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download">here&lt;/a> - that&amp;rsquo;s basically 64-bit GCC for Windows.&lt;/li>
&lt;li>Run the installer. Make sure to change the &lt;strong>Architecture&lt;/strong> setting to &lt;code>x86_64&lt;/code>, otherwise you&amp;rsquo;ll get a 32-bit toolchain and that&amp;rsquo;s not what we want here. Also; make sure the &lt;strong>Threads&lt;/strong> setting is configured as &lt;code>posix&lt;/code>, otherwise you won&amp;rsquo;t be able to use standard C++ threading library. Don&amp;rsquo;t change other settings there.
&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/mingw-install-win.png" alt="mingw-w64-installer">&lt;/li>
&lt;li>After installation, add the &lt;code>/bin&lt;/code> subdirectory (with &lt;code>gcc.exe&lt;/code> and &lt;code>g++.exe&lt;/code> inside) of installed toolchain to system PATH variable. &lt;em>It, obviously, can be different than the one on the screenshot below&lt;/em>
&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/mingw-bin-dir.png" alt="mingw-bin-dir">
Go to &amp;ldquo;Edit the system environment variables&amp;rdquo; settings in Windows, then press the &amp;ldquo;Environment variables&amp;hellip;&amp;rdquo; button and add the new entry with GCC bin directory, either to user, or system PATH variable - doesn&amp;rsquo;t really matter which one.
&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/env-vars.png" alt="env-vars">&lt;/li>
&lt;li>Check if you&amp;rsquo;ve done it correctly by running PowerShell or &lt;code>cmd.exe&lt;/code> and trying out &lt;code>gcc --version&lt;/code> command. You should see something like this:
&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/gcc-installed.png" alt="gcc-installed">
If that&amp;rsquo;s not what you see, check if you&amp;rsquo;ve added correct path to PATH variable. Or restart the shell/computer, and try again.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>Important note about MinGW and MinGW-w64&lt;/strong> - Both official MinGW and MinGW-w64 distributions are pretty outdated (they&amp;rsquo;re using GCC 8.1.0, while the latest release at the time of writing is 11.0). If you want a fresh new version of GCC on your Windows machine, either use &lt;a href="https://www.msys2.org/">MSYS2&lt;/a> or &lt;a href="https://winlibs.com/">WinLibs package&lt;/a>. However, MSYS2 setup is a bit longer than MinGW, and both of these packages can have their issues (i&amp;rsquo;ve managed to get issues with WinAPI and terminal output using both of them), so if you&amp;rsquo;re an absolute beginner, stick to MinGW-w64 for a while.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>For Linux&lt;/strong>:&lt;/p>
&lt;p>Usually, you should have GCC in your repository. On Ubuntu, Debian and similar distributions (Mint, Kubuntu, Lubuntu, PopOS!, Zorin, and so on), you have &lt;code>build-essential&lt;/code> package with most tools needed to build C/C++ programs.&lt;/p>
&lt;p>On Arch Linux and similar distributions (Manjaro), you have &lt;code>base-devel&lt;/code> package.&lt;/p>
&lt;p>On other distributions, search for similar package or install latest &lt;code>gcc&lt;/code> and &lt;code>g++&lt;/code> packages from your repository.&lt;/p>
&lt;p>Test it the same way as on Windows - open terminal and try &lt;code>gcc --version&lt;/code>, see what happens.&lt;/p>
&lt;p>&lt;strong>You also have to install &lt;code>gdb&lt;/code> (GCC debugger) separately, as it may not come with the base development packages, and you definitely do want to have it and use it.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>For MacOS&lt;/strong>: probably same thing as on Linux, look for GCC (or any other preferred toolchain) in package manager and install it from there. Verify the installation the same way as on Linux.&lt;/p>
&lt;h2 id="vscode-essential-plugins">VSCode Essential Plugins&lt;/h2>
&lt;p>If you already have working C/C++ toolchain, time to run VSCode and install some plugins. Run VSCode and go to the &lt;em>Extensions&lt;/em> menu.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-ext-1.png" alt="vsc-ext-1">&lt;/p>
&lt;p>Now, for some general C++ plugins:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>C/C++&lt;/strong> - that&amp;rsquo;s the core extension we&amp;rsquo;ll need. It contains the fundamental stuff to work with C/C++ in VSCode.&lt;/li>
&lt;li>&lt;strong>Better C++ Syntax&lt;/strong> - it&amp;rsquo;s always nice to have better syntax colouring, so i strongly recommend that one. &lt;em>You might want to use one of the themes from this extension description to get full experience.&lt;/em>&lt;/li>
&lt;li>&lt;strong>C/C++ Snippets&lt;/strong> - pretty useful extension that adds automatic generation of snippets in C/C++ code - instead of writing loops, structures and class definitions by hand, you can generate them with autocompletion support.&lt;/li>
&lt;li>&lt;strong>C++ Intellisense&lt;/strong> - pretty good plugin with some intelligent autocompletion features.&lt;/li>
&lt;li>&lt;strong>C++ Helper&lt;/strong> - simple extension which adds automatic function definition generation feature.&lt;/li>
&lt;li>&lt;strong>C-mantic&lt;/strong> - very useful plugin that adds auto-generation of function definitions, getters, setters and more. &lt;strong>An alternative to C++ Helper - pick whatever seems more ergonomic for you&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>And i&amp;rsquo;d also recommend these:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bracket Pair Colorizer 2&lt;/strong> - very useful extension which colorize the matching bracket pairs, increasing code clarity. Strongly recommended.&lt;/li>
&lt;li>&lt;strong>GitLens&lt;/strong> - if you want to work with Git repositories, that&amp;rsquo;s the extension you&amp;rsquo;re looking for. &lt;strong>You need &lt;code>git&lt;/code> installed to use it!&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Material Icon Theme&lt;/strong> - better looking than default ones&lt;/li>
&lt;/ul>
&lt;p>With these plugins, you will have a pretty decent bare-bones environment to work with C and C++. You&amp;rsquo;ll have autocompletion, some refactoring features, some code generation and a pretty decent syntax highlighting. &lt;em>The screenshot below is outdated - use the list above for updated recommended plugins&lt;/em>&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/installed-ext-vscode.png" alt="installed-ext">&lt;/p>
&lt;blockquote>
&lt;p>I have one more plugin to show you, an alternative language server with many useful features, but i&amp;rsquo;ll leave it as a bonus at the end of this guide, because it needs a bit more configuration. Make sure to check it out!&lt;/p>
&lt;/blockquote>
&lt;h2 id="creating-a-project---vscode-and-cmake">Creating a project - VSCode and CMake&lt;/h2>
&lt;p>We&amp;rsquo;ll start with something simple. As i&amp;rsquo;ve mentioned before, i&amp;rsquo;m not gonna teach you how to make a &lt;em>raw&lt;/em> VSCode project, which builds the app from scratch and without any other tools, because that&amp;rsquo;s simply painful, not really scalable, and not worth the trouble.&lt;/p>
&lt;p>Instead, i&amp;rsquo;m gonna teach you how to use a build system.&lt;/p>
&lt;h3 id="but-whats-a-build-system">But what&amp;rsquo;s a &lt;em>build system&lt;/em>?&lt;/h3>
&lt;p>Well, build system is a tool that tells the toolchain (compiler and his friends) how to create a program out of all the source (and resource) files you&amp;rsquo;ve created. And sometimes does other things, but that&amp;rsquo;s out of this tutorial scope.&lt;/p>
&lt;p>Without it, you&amp;rsquo;d have to enter the toolchain commands manually each time you&amp;rsquo;d want to build the application. That&amp;rsquo;s fine for small apps with one, two or maybe five files. But it gets messy when your program starts to grow.&lt;/p>
&lt;p>So, for example, assuming you use &lt;code>gcc&lt;/code>, to build your C program manually, you&amp;rsquo;d have to enter something like this:&lt;/p>
&lt;p>&lt;code>gcc [list of your source files] [some fancy flags for your compiler] [maybe some flags telling the compiler where the libraries are] -o program.exe&lt;/code>&lt;/p>
&lt;p>An actual example would be:&lt;/p>
&lt;p>&lt;code>gcc main.c lib.c lib2.c -O2 -Wall -Wextra -L./some/lib -lmylib -lsomeotherlib -o program.exe&lt;/code>&lt;/p>
&lt;p>That doesn&amp;rsquo;t look so bad, right? You could even put this command in some shell script and easily run it every time you&amp;rsquo;d like to build the code. But then, you&amp;rsquo;d have to change this command every time your project structure changes - so, every time you add a new file, or library, or change some directory name, you gotta edit this script. &lt;em>And yes, i know that wildcards exist, but for the sake of this example i&amp;rsquo;m gonna ignore them.&lt;/em>&lt;/p>
&lt;p>Another issue is that if you&amp;rsquo;d want to give this code to your friend or teacher, he would either have to use the same shell as you, and &lt;code>gcc&lt;/code>, or write his own build script (or project) for the compiler/shell he&amp;rsquo;s using, and that&amp;rsquo;s not very user-friendly (or, rather, programmer-friendly) solution.&lt;/p>
&lt;p>There are also some other issues with manual building, but the point is: &lt;strong>manual building is not comfortable or scalable on a larger scale&lt;/strong>. So, we&amp;rsquo;ll use a build system to do it for us and make everyone&amp;rsquo;s life easier!&lt;/p>
&lt;p>&lt;em>Bonus note: Tool i&amp;rsquo;m going to talk about next - CMake - isn&amp;rsquo;t technically a build system. It&amp;rsquo;s a meta-build system. The difference between those is that build system runs the toolchain commands directly, while meta-build system generates the build system files. Basically, meta-build systems are more flexible, and sometimes easier to use, therefore we&amp;rsquo;re gonna use one.&lt;/em>&lt;/p>
&lt;p>&lt;em>Bonus note number two: originally, i was going to show how to use Premake and CMake, but due to some &lt;a href="https://github.com/premake/premake-core/issues/1640">pretty bad issues with Premake&lt;/a> i&amp;rsquo;ve decided to stay with CMake. I&amp;rsquo;ll probably make a Premake guide in the future.&lt;/em>&lt;/p>
&lt;h4 id="okay-how-do-i-use-it">Okay, how do i use it?&lt;/h4>
&lt;p>Well, let&amp;rsquo;s start with installation. You can either install it from your package manager, just like VSCode, or download from &lt;a href="https://cmake.org/download/">official site&lt;/a>. &lt;strong>Make sure to add CMake to your PATH variable if you&amp;rsquo;re using an official installer!&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>Important note: if you&amp;rsquo;re using your package manager, check the CMake version after installation (&lt;code>cmake --version&lt;/code> command). I&amp;rsquo;m gonna use some stuff that was added in CMake 3.12, but from what i can see, some older Linux distributions (like Ubuntu 18.04) &lt;a href="https://packages.ubuntu.com/search?keywords=cmake">still have CMake 3.10 in their repositories&lt;/a>, so if that&amp;rsquo;s the case i strongly recommend installing newer version manually. If that&amp;rsquo;s not possible, i&amp;rsquo;ll tell what things come from CMake 3.12 and how to make a workaround.&lt;/p>
&lt;/blockquote>
&lt;p>Done? Great. Now a little bit of theory.&lt;/p>
&lt;h4 id="how-does-cmake-work">How does CMake work?&lt;/h4>
&lt;p>CMake is a meta-build system. As i&amp;rsquo;ve mentioned earlier, it means that when we run it, it should give us a project for a build system of our choice, which we can use to build our application. To tell CMake how it should generate the project, a &lt;code>CMakeLists.txt&lt;/code> file is used. This file includes the project configuration, written in CMake&amp;rsquo;s scripting language.&lt;/p>
&lt;p>Some toolchains - like GCC, MinGW or Visual C++ - come with their own build systems. In case of GCC/MinGW, it&amp;rsquo;s GNU Make. In case of Visual C++, it&amp;rsquo;s MSBuild. CMake can generate the necessary files for these build systems, and then we can use them to build the whole project with a single command. Pretty convenient.&lt;/p>
&lt;h3 id="creating-a-simple-project">Creating a simple project&lt;/h3>
&lt;p>Let&amp;rsquo;s open VSCode (or restart, if you had it opened while installing CMake) and add some extensions.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-ext.png" alt="cmake-ext">&lt;/p>
&lt;p>These two plugins will enable &lt;code>CMakeLists.txt&lt;/code> syntax highlighting and CMake integration for VSCode. And this integration is a very powerful and helpful tool, as we&amp;rsquo;ll see in a bit. &lt;em>You can also install a &lt;code>cmake-format&lt;/code> extension, if you have Python installed and follow the &lt;a href="https://marketplace.visualstudio.com/items?itemName=cheshirekow.cmake-format">plugin&amp;rsquo;s installation guide&lt;/a>&lt;/em>&lt;/p>
&lt;p>Now, make a folder for our new project and create a simple &lt;code>main.cpp&lt;/code> (or &lt;code>main.c&lt;/code>, if you want to code in C):&lt;/p>
&lt;p>C++ version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, world!&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, world!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can check if your toolchain works correctly by building the app manually. If you&amp;rsquo;re using GCC or MinGW, open up integrated VSCode terminal with &lt;code>Ctrl+` &lt;/code> command (or &lt;code>Ctrl+Shift+` &lt;/code> to create a new one), and run:&lt;/p>
&lt;p>C++: &lt;code>g++ main.cpp -o main&lt;/code>&lt;/p>
&lt;p>C: &lt;code>gcc main.c -o main&lt;/code>&lt;/p>
&lt;p>And then run the app with &lt;code>./main&lt;/code> command. You should see your Hello World printed in terminal.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/hello-world-first-run.png" alt="hello-world-manual">&lt;/p>
&lt;p>&lt;em>If that doesn&amp;rsquo;t work, make sure you have correctly added your toolchain to PATH variable.&lt;/em>&lt;/p>
&lt;p>Now, we can proceed with CMake. Delete the compiled program &lt;code>main&lt;/code> you just created and tested, and create a &lt;code>CMakeLists.txt&lt;/code> file in the same directory as your code file. We&amp;rsquo;ll start with bare-bones template and then we&amp;rsquo;ll expand it a little.&lt;/p>
&lt;p>Put this code into &lt;code>CMakeLists.txt&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>cmake_minimum_required(&lt;span style="color:#e6db74">VERSION&lt;/span> &lt;span style="color:#e6db74">3.12&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change CXX to C, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>project(&lt;span style="color:#e6db74">HelloWorld&lt;/span> &lt;span style="color:#e6db74">LANGUAGES&lt;/span> &lt;span style="color:#e6db74">CXX&lt;/span>) &lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change main.cpp to main.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>add_executable(&lt;span style="color:#f92672">${&lt;/span>PROJECT_NAME&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#e6db74">main.cpp&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then open up the VSCode command list with &lt;code>Ctrl+Shift+P&lt;/code> shortcut, and look for &lt;code>CMake: Configure&lt;/code> option. Run it.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-configure-cmd.png" alt="cmake-config">&lt;/p>
&lt;p>Next, you should see a list of detected toolchains installed in your system. Pick one.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-select-kit.png" alt="cmake-select-kit">&lt;/p>
&lt;p>After that, VSCode will run CMake and configure the project for the first time. You should see similar output in your VSCode output window:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-output.png" alt="cmake-config-out">&lt;/p>
&lt;p>From now on, VSCode will automatically run CMake every time you change &lt;code>CMakeLists.txt&lt;/code> to re-generate the project files. You should also see a new menu on left-side toolbar&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-menu.png" alt="cmake-menu">&lt;/p>
&lt;h4 id="building-your-program">Building your program&lt;/h4>
&lt;p>So, we have a project now. How do we build it, and how do we run our program?&lt;/p>
&lt;p>Thankfully, CMake plugin for VSCode got us covered. To build the program, either use &lt;code>F7&lt;/code> shortcut, look for the &lt;code>CMake: Build&lt;/code> command in command list, or press the &lt;code>Build&lt;/code> button either on VSCode bottom bar, or in CMake menu.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/build-bottom-bar.png" alt="build-from-bar">&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/build-cmake-menu.png" alt="build-from-menu">&lt;/p>
&lt;p>You should see similar output in VSCode output window:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/build-output.png" alt="build-output">&lt;/p>
&lt;h4 id="running-your-program">Running your program&lt;/h4>
&lt;p>Now, let&amp;rsquo;s run it. Press the &lt;code>Run&lt;/code> button on the bottom VSCode bar:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/run-bottom-bar.png" alt="run-app">&lt;/p>
&lt;p>And the app should run without any issues. The output should be in terminal window.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-run.png" alt="app-run">&lt;/p>
&lt;h4 id="is-that-it">Is that it?&lt;/h4>
&lt;p>&lt;strong>Of course not - there&amp;rsquo;s always more!&lt;/strong>&lt;/p>
&lt;p>But yeah, we just created a very simple project with CMake + VSCode, built it and ran it. Now, let&amp;rsquo;s talk what actually happened and how can we expand our project.&lt;/p>
&lt;h2 id="cmake-101---how-does-it-work">CMake 101 - how does it work?&lt;/h2>
&lt;p>CMake, as i&amp;rsquo;ve mentioned multiple times, is a tool that generates the project files used to build it. However, it can also be used for some other things - like application packaging, managing tests, configuring the project, and so on. At the moment CMake is an &lt;em>industry standard&lt;/em>, which means that most of the C and C++ projects have CMake support, therefore it&amp;rsquo;s a very versatile tool. Not the best, but versatile.&lt;/p>
&lt;p>You may notice that after configuring the project a new directory appeared in your project folder, called &lt;code>build&lt;/code>. Let&amp;rsquo;s peek into it.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-build-dir.png" alt="cmake-build-dir">&lt;/p>
&lt;p>You are usually not supposed to touch and modify these files, as CMake manages them, but i&amp;rsquo;ll still explain the function of some of the more important ones:&lt;/p>
&lt;ul>
&lt;li>&lt;code>CMakeCache.txt&lt;/code> - inside that file, you can find a list of CMake variables that are used in project generation process. You can find the toolchain paths, compiler flags, user and many different configuration variables there.&lt;/li>
&lt;li>&lt;code>compile_commands.json&lt;/code> - that file contains a list of commands used to build your program. This list can be used by some code analyzing tools (and i&amp;rsquo;ll describe one at the end of this guide).&lt;/li>
&lt;li>&lt;code>HelloWorld.exe&lt;/code> - hey, that&amp;rsquo;s our program!&lt;/li>
&lt;li>&lt;code>Makefile&lt;/code> - this file is used by GNU Make to build our program. Basically, that&amp;rsquo;s the final CMake output. If you&amp;rsquo;re using a different toochain with different build system, like Visual C++, you will get a different file (usually, a whole Visual Studio solution, so maybe even a whole directory).&lt;/li>
&lt;/ul>
&lt;h3 id="cmakelists---whats-inside">CMakeLists - what&amp;rsquo;s inside?&lt;/h3>
&lt;p>Let&amp;rsquo;s analyze our &lt;code>CMakeLists.txt&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>cmake_minimum_required(&lt;span style="color:#e6db74">VERSION&lt;/span> &lt;span style="color:#e6db74">3.12&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change CXX to C, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>project(&lt;span style="color:#e6db74">HelloWorld&lt;/span> &lt;span style="color:#e6db74">LANGUAGES&lt;/span> &lt;span style="color:#e6db74">CXX&lt;/span>) &lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change main.cpp to main.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>add_executable(&lt;span style="color:#f92672">${&lt;/span>PROJECT_NAME&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#e6db74">main.cpp&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>cmake_minimum_required&lt;/code> defines the minimal version of CMake required to generate this project. We&amp;rsquo;ll use 3.12 because i&amp;rsquo;m gonna show you some stuff that was added in this version.&lt;/li>
&lt;li>&lt;code>project&lt;/code> defines our project. We can also add information about version, project description, homepage and used languages - which we do in that case.&lt;/li>
&lt;li>&lt;code>add_executable&lt;/code> tells CMake to generate a code that will build an executable file with specified name from specified source files. &lt;code>${PROJECT_NAME}&lt;/code> is a CMake variable containing the project name defined by &lt;code>project&lt;/code> command.&lt;/li>
&lt;/ul>
&lt;p>It&amp;rsquo;s important that &lt;code>add_executable&lt;/code> requires a full list of all the source files making up the program. So, in theory, you would have to add every single source file to the list manually, like that: &lt;code>add_executable(${PROJECT_NAME} main.cpp a.cpp b.cpp [...])&lt;/code>, but fortunately that&amp;rsquo;s not necessary. We can use &lt;code>file&lt;/code> command to generate that list for us.&lt;/p>
&lt;h3 id="expanding-our-project---adding-more-files">Expanding our project - adding more files&lt;/h3>
&lt;p>Let&amp;rsquo;s add some more files for our project. First, create two new directories - &lt;code>include&lt;/code> and &lt;code>src&lt;/code> in root project directory:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/src-include-dirs.png" alt="src-include-dirs">&lt;/p>
&lt;p>Now, move the &lt;code>main.cpp&lt;/code> (or &lt;code>main.c&lt;/code>) to &lt;code>src&lt;/code> directory, and make a new file called &lt;code>lib.cpp&lt;/code> (or &lt;code>lib.c&lt;/code>) there. Put this code inside:&lt;/p>
&lt;p>C++ version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.hpp&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, i&amp;#39;m a library!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">x = &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, i&amp;#39;m a library!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">x = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, add a &lt;code>lib.hpp&lt;/code> (or &lt;code>lib.h&lt;/code>) file inside &lt;code>include&lt;/code> directory. Put this inside:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pragma once
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The project should look like this now:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/project-new-files.png" alt="project-expanded">&lt;/p>
&lt;p>Let&amp;rsquo;s update the &lt;code>CMakeLists.txt&lt;/code>.&lt;/p>
&lt;p>We&amp;rsquo;ll use two new commands now: &lt;code>file&lt;/code> and &lt;code>include_directories&lt;/code>. &lt;code>file&lt;/code> command will generate the list of source files, while &lt;code>include_directories&lt;/code> will tell our toolchain where to look for header files.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>cmake_minimum_required(&lt;span style="color:#e6db74">VERSION&lt;/span> &lt;span style="color:#e6db74">3.12&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change CXX to C, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>project(&lt;span style="color:#e6db74">HelloWorld&lt;/span> &lt;span style="color:#e6db74">LANGUAGES&lt;/span> &lt;span style="color:#e6db74">CXX&lt;/span>) &lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change *.cpp to *.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>file(&lt;span style="color:#e6db74">GLOB&lt;/span> &lt;span style="color:#e6db74">PROJECT_SOURCE_FILES&lt;/span> &lt;span style="color:#e6db74">CONFIGURE_DEPENDS&lt;/span> &lt;span style="color:#e6db74">src/*.cpp&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>include_directories(&lt;span style="color:#e6db74">include/&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change main.cpp to main.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>add_executable(&lt;span style="color:#f92672">${&lt;/span>PROJECT_NAME&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">${&lt;/span>PROJECT_SOURCE_FILES&lt;span style="color:#f92672">}&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>file(GLOB PROJECT_SOURCE_FILES CONFIGURE_DEPENDS src/*.cpp)&lt;/code> - this command generates the list of files from &lt;code>src&lt;/code> dir with &lt;code>.cpp&lt;/code> extension, and stores it in &lt;code>PROJECT_SOURCE_FILES&lt;/code> variable. The &lt;code>CONFIGURE_DEPENDS&lt;/code> flag was added in CMake 3.12, and thanks to it, the list of files will be automatically re-generated every time we add a new file to the project. The command will work without it, but then you would have to manually regenerate CMake project after adding new files.&lt;/li>
&lt;li>&lt;code>include_directories&lt;/code> tells the toolchain where to look for header files.&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>PROJECT_SOURCE_FILES&lt;/code> variable should have a list of all of our code files, and we&amp;rsquo;ll pass it to &lt;code>add_executable&lt;/code> instead of adding a new file manually.
Of course, this variable can be called anyhow you want - it&amp;rsquo;s not a special name or anything.&lt;/p>
&lt;p>Now, let&amp;rsquo;s configure our project again (VSCode should do this automatically, but i wanna show you how to do it in case it doesn&amp;rsquo;t). Right-click on &lt;code>CMakeLists.txt&lt;/code> and select &amp;ldquo;Configure All Projects&amp;rdquo;&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmakelists-config.png" alt="cmake-reconfig">&lt;/p>
&lt;blockquote>
&lt;p>Sometimes, when something goes wrong and CMake or VSCode starts behaving strange or getting buggy, it&amp;rsquo;s good to clean up and reconfigure the project (&amp;ldquo;Clean Reconfigure All Projects&amp;rdquo; and &amp;ldquo;Clean Rebuild All Projects&amp;rdquo;). This can sometimes happen when playing with CMakeLists.&lt;/p>
&lt;/blockquote>
&lt;p>Let&amp;rsquo;s add some code to our &lt;code>main.cpp&lt;/code> (or &lt;code>main.c&lt;/code>) to test if additional files are added properly to our project:&lt;/p>
&lt;p>C++ version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.hpp&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, world&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f(&lt;span style="color:#ae81ff">42&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, world!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#ae81ff">42&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we should be able to build our program&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/lib-build.png" alt="lib-build">&lt;/p>
&lt;p>And run it&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/lib-run.png" alt="lib-run">&lt;/p>
&lt;p>At this point, everything should work automatically. You should be able to add new source files to &lt;code>src&lt;/code> dir, and new headers to &lt;code>include&lt;/code>, and CMake should handle them without having to touch &lt;code>CMakeLists.txt&lt;/code> manually. Adding new directories with source/include files is done the same way - just &lt;code>file&lt;/code> the source files, add include path with &lt;code>include_directories&lt;/code> and voila.&lt;/p>
&lt;h3 id="debugging-our-code">Debugging our code&lt;/h3>
&lt;p>Time for a last step in our setup - using a debugger. Fortunately, CMake integration does most of the work for us here.&lt;/p>
&lt;p>Let&amp;rsquo;s add a breakpoint in the first line of our &lt;code>main&lt;/code> function - click on the left of line number, you should see a red dot:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/vsc-breakpoint.png" alt="vsc-breakpoint">&lt;/p>
&lt;p>And start a debugging session by pressing a little bug icon on the bottom of VSCode window, or by using &lt;code>CMake: Debug&lt;/code> command&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/vsc-debug-icon.png" alt="vsc-debug-cmd">&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-debug.png" alt="vsc-debug-icon">&lt;/p>
&lt;p>VSCode should now switch into debugging perspective and program should stop at breakpoint.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-debug-perspective.png" alt="vsc-debug-perspective">&lt;/p>
&lt;p>And that&amp;rsquo;s basically it. Don&amp;rsquo;t worry about lack of configuration for run/debug in VSCode - CMake integration does everything for us, so there&amp;rsquo;s no need to make them. Just make sure you run/debug the program via CMake commands in VSCode, instead of it&amp;rsquo;s own. Setting up the run/debug configs manually can be pretty annoying at the times, so that&amp;rsquo;s a subject for another guide.&lt;/p>
&lt;p>There&amp;rsquo;s one subject i haven&amp;rsquo;t touched yet, and it&amp;rsquo;s adding external libraries. Since this guide is already long enough, i&amp;rsquo;ll make another one for that.
Now, it&amp;rsquo;s the time for some bonus content.&lt;/p>
&lt;h2 id="bonus-clangd-setup">Bonus: clangd setup&lt;/h2>
&lt;p>&lt;code>clangd&lt;/code> is a language server for C++. It provides functionalities like code completion, code linting (showing warning and errors in real-time), simple refactoring, and so on. There is a C++ language server in VSCode already, as we installed &lt;code>C/C++&lt;/code> extension, but &lt;code>clangd&lt;/code> is better in some ways, and it&amp;rsquo;s more multi-platform (default VSCode C++ language server doesn&amp;rsquo;t work on ARM yet, so if you wanna code on RaspberryPi via SSH - &lt;code>clangd&lt;/code> is your best friend).&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/ext-clang.png" alt="clangd-plugin">&lt;/p>
&lt;p>In order to work, &lt;code>clangd&lt;/code> requires &lt;code>compile_commands.json&lt;/code> file to know how your code is compiled and with what flags. Fortunately for us, CMake generates that file automatically, so no further configuration is required on our side!&lt;/p>
&lt;p>Right after the plugin installation, you should see a popup like this one:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-install.png" alt="clangd-install">&lt;/p>
&lt;p>In order for &lt;code>clangd&lt;/code> to work, you have to disable the default Intellisense server (press &lt;code>Disable IntelliSense&lt;/code>), and download &lt;code>clangd&lt;/code> binary (which VSCode does for us). After it&amp;rsquo;s downloaded, you should see this popup:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-installed.png" alt="clangd-installed">&lt;/p>
&lt;p>Reload the window, open up a C/C++ source file, and check if &lt;code>clangd&lt;/code> info is displayed on the bottom of the screen&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-idle.png" alt="clangd-idle">&lt;/p>
&lt;p>If that&amp;rsquo;s the case, congratulations, it should work now. Check if there&amp;rsquo;s no &lt;code>include&lt;/code> errors, and if the autocompletion works (you can manually trigger autocompletion with &lt;code>Ctrl+Space&lt;/code> shortcut). There should also be a &lt;code>.cache&lt;/code> directory in your project folder now, with &lt;code>clangd&lt;/code>&amp;rsquo;s cache files - make sure to add it to &lt;code>.gitignore&lt;/code> before making a commit :P&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-cache.png" alt="clangd-cache">&lt;/p>
&lt;p>Full list of &lt;code>clangd&lt;/code> features can be found here: &lt;a href="https://clangd.llvm.org/features.html">https://clangd.llvm.org/features.html&lt;/a>. I strongly recommend checking it out.&lt;/p>
&lt;h3 id="clang-format-setup">Clang-Format setup&lt;/h3>
&lt;p>&lt;code>clangd&lt;/code> embeds &lt;code>clang-format&lt;/code> support, which is a code formatting tool - one of the best in C and C++ environment. &lt;code>clang-format&lt;/code> allows you to manually or automatically format the code (for example, on-save, format-while-typing is not yet supported with &lt;code>clangd&lt;/code>) according to your preferences, which you can set by creating &lt;code>.clang-format&lt;/code> file in your workspace root, with configuration options for &lt;code>clang-format&lt;/code>.&lt;/p>
&lt;p>The list of configuration options is pretty long and can be found here: &lt;a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">https://clang.llvm.org/docs/ClangFormatStyleOptions.html&lt;/a>. I&amp;rsquo;m not gonna describe them all of course, i&amp;rsquo;ll just show an setup example.&lt;/p>
&lt;p>Let&amp;rsquo;s create a &lt;code>.clang-format&lt;/code> file in our workspace root dir, and put this inside:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-clang-format" data-lang="clang-format">BasedOnStyle: Chromium
IndentWidth: 2
Standard: c++17
BreakBeforeBraces: Linux
&lt;/code>&lt;/pre>&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/clang-format.png" alt="clang-format">&lt;/p>
&lt;p>If &lt;code>clangd&lt;/code> is the only formatter you have installed, it should be treated as default. If not, make sure it is by opening command list (&lt;code>Ctrl+Shift+P&lt;/code>), looking for &lt;code>Format Document With...&lt;/code> option, and setting default formatter to &lt;code>clangd&lt;/code>.&lt;/p>
&lt;p>Now, open a &lt;code>main&lt;/code> file and either right-click and pick &lt;code>Format document&lt;/code> option, or use a shortcut (&lt;code>Shift+Alt+F&lt;/code> on Windows by default). The code should now look like this:&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/main-formatted.png" alt="main-formatted">&lt;/p>
&lt;p>If it had been formatted differently, check the &lt;code>clangd&lt;/code> output in VSCode window. All the issues and errors with &lt;code>.clang-format&lt;/code> file should be there.&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-output.png" alt="clangd-output">&lt;/p>
&lt;p>You can set autoformatting in VSCode settings - open settings window with &lt;code>Ctrl+,&lt;/code> or &lt;code>File -&amp;gt; Preferences -&amp;gt; Settings&lt;/code>, and look for &lt;code>format on&lt;/code> options&lt;/p>
&lt;p>&lt;img src="https://steelph0enix.github.io/img/vscode-cpp-setup/vsc-format-settings.png" alt="vsc-format-on">&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>And that would be it. I hope it&amp;rsquo;s not too long.&lt;/p>
&lt;p>If there are any issues or questions about the guide itself or the setup process, feel free to &lt;a href="https://steelph0enix.github.io/about/">contact me&lt;/a>!&lt;/p></content></item></channel></rss>