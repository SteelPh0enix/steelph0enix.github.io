<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guide on</title><link>https://steelph0enix.github.io/tags/guide/</link><description>Recent content in Guide on</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>SteelPh0enix's Blog Â© 2021-2024 by SteelPh0enix is licensed under CC BY-SA 4.0</copyright><lastBuildDate>Thu, 29 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://steelph0enix.github.io/tags/guide/index.xml" rel="self" type="application/rss+xml"/><item><title>Making C/C++ project template in Meson - part 2.5</title><link>https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2-5/</link><pubDate>Thu, 29 Feb 2024 00:00:00 +0000</pubDate><guid>https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2-5/</guid><description>&lt;h2 id="fixing-cpputest-wrap-and-contributing-to-wrapdb">Fixing CppUTest wrap and contributing to WrapDB&lt;/h2>
&lt;p>As per &lt;a href="https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2/">my previous post&lt;/a>, &lt;a href="https://github.com/mesonbuild/wrapdb/pull/1398">I have fixed&lt;/a> the CppUTest wrap and it&amp;rsquo;s now available on WrapDB!
Since this post series is strictly related to Meson, I want to talk a bit more about creating wraps and contributing there.
If you don&amp;rsquo;t care, and just want to continue to the guide part - jump to the &lt;a href="https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2-5/#adding-unit-tests-support">next section&lt;/a>.&lt;/p>
&lt;p>I have started the process of creating this wrap by making a very basic example project with a single binary that uses CppUTest.
Then, I plugged in CppUTest as a normal subproject, and began rewriting the &lt;code>meson.build&lt;/code> files, along with the options.
Eventually I&amp;rsquo;ve managed to get to a point where it compiled successfully on my setup, linked to an app, and I was able to run it.
Thinking that&amp;rsquo;s good enough, I&amp;rsquo;ve started worrying about wrapping it properly.&lt;/p></description><content>&lt;h2 id="fixing-cpputest-wrap-and-contributing-to-wrapdb">Fixing CppUTest wrap and contributing to WrapDB&lt;/h2>
&lt;p>As per &lt;a href="https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2/">my previous post&lt;/a>, &lt;a href="https://github.com/mesonbuild/wrapdb/pull/1398">I have fixed&lt;/a> the CppUTest wrap and it&amp;rsquo;s now available on WrapDB!
Since this post series is strictly related to Meson, I want to talk a bit more about creating wraps and contributing there.
If you don&amp;rsquo;t care, and just want to continue to the guide part - jump to the &lt;a href="https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2-5/#adding-unit-tests-support">next section&lt;/a>.&lt;/p>
&lt;p>I have started the process of creating this wrap by making a very basic example project with a single binary that uses CppUTest.
Then, I plugged in CppUTest as a normal subproject, and began rewriting the &lt;code>meson.build&lt;/code> files, along with the options.
Eventually I&amp;rsquo;ve managed to get to a point where it compiled successfully on my setup, linked to an app, and I was able to run it.
Thinking that&amp;rsquo;s good enough, I&amp;rsquo;ve started worrying about wrapping it properly.&lt;/p>
&lt;p>There are few different kinds of wraps that Meson supports.
If the project supports Meson, CMake or Cargo it can be wrapped directly, either as an archive or a specific revision of code on a supported repository.
Otherwise, it&amp;rsquo;s possible to provide an &amp;ldquo;overlay&amp;rdquo; patch that adds/replaces the files of the library in order to provide Meson support - that&amp;rsquo;s what file-wraps are.&lt;/p>
&lt;p>I&amp;rsquo;ve considered it before, but to be clear - CppUTest&amp;rsquo;s primary build system is CMake, but I don&amp;rsquo;t have much pleasant memories related to CMake and I&amp;rsquo;d prefer to avoid interacting with it.&lt;/p>
&lt;p>I already had the files necessary to create a file-wrap, so all I needed to do was modifying &lt;code>cpputest.wrap&lt;/code>&amp;hellip; Right?
Wrong!
This is where I&amp;rsquo;ve spent an hour or two, thinking that I can host this on my Github repo instead of contributing to WrapDB.
And this is my first major complaint about Meson!&lt;/p>
&lt;p>First thing I wanted to try was putting the wrap patch files on my Github repository, and pointing the wrap to it.
I&amp;rsquo;ve figured that this way should be supported, because it enables hosting wraps on private repositories, for example in company environments.
So i did that, created a release to have an archive, pointed the wrap to it, and&amp;hellip; It did not work, because Meson kept putting the patch files in different directory than source files.&lt;/p>
&lt;p>I was thinking that &lt;code>directory&lt;/code> option in &lt;code>.wrap&lt;/code> file defines the directory both archives will be extracted to, but that&amp;rsquo;s not the case!
This is the option that defines where the &lt;strong>source archive&lt;/strong> will be extracted to, but not the &lt;strong>patch archive&lt;/strong>.
And the output directory for patch was dependent on&amp;hellip; The name of my repository. Duh.
Effectively, I think that I&amp;rsquo;d have to name my repository with the wrap &lt;code>cpputest&lt;/code> to make it working that way, and I&amp;rsquo;d rather not do that&amp;hellip;
So I&amp;rsquo;ve abandoned this idea and proceeded to read &lt;a href="https://mesonbuild.com/Adding-new-projects-to-wrapdb.html">how to contribute to WrapDB&lt;/a>.
Alas, I believe that this way of providing files for file-wraps should be supported.&lt;/p>
&lt;p>The contribution itself was rather pleasant experience - after moving the wrap files to the WrapDB fork, I&amp;rsquo;ve made a pull request and waited for CI to pass.
I was happy to see the CI checked the code by running a Python script with no external dependencies, so I could run the checks locally.
I was even more happy to see that this script actually downloaded and built every library WrapDB supports, and CI was running it on Windows, Linux and MacOS runners with Clang, GCC and MSVC.
That is a nice thing, but as we experienced, it&amp;rsquo;s not quite enough to guarantee quality - even practically unusable wraps can build with no issues.
I was less happy when I&amp;rsquo;ve enabled the CI on my fork and it ate 1/4th of my monthly free GitHub runner limit after a single full run.
Oh well.
Good thing they do incremental builds on PRs.&lt;/p>
&lt;p>Of course, my PR it did not pass the CI first time - it forced me to add some functionality to the wrap (platform autodetection), but after that it was good to go and got merged.
The whole process took only a few hours, the PR was reviewed, the CI did it&amp;rsquo;s job - no complains there.&lt;/p>
&lt;h2 id="adding-unit-tests-support">Adding unit tests support&lt;/h2>
&lt;p>Now we can proceed with the actual subject of this post.&lt;/p>
&lt;p>Remove everything from the &lt;code>subprojects/&lt;/code> directory, open a terminal and run &lt;code>meson wrap install cpputest&lt;/code>.
This is the preferred method of installing wraps, and I forgot to mention it earlier.
I don&amp;rsquo;t quite understand why it&amp;rsquo;s not able to create &lt;code>subprojects/&lt;/code> directory by itself by default, but it&amp;rsquo;s a non-issue.&lt;/p>
&lt;p>I assume that you&amp;rsquo;ve followed the previous part, and already added &lt;code>tests&lt;/code> directory to main &lt;code>meson.build&lt;/code>, and created example test in &lt;code>tests/calc/&lt;/code>.
If not, &lt;a href="https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2/#managing-external-dependencies-with-meson">go back and do that&lt;/a>.
If you already did that, then the project should compile successfully.
The only thing I&amp;rsquo;d like to change is &lt;code>cpputest_dependency&lt;/code> to just &lt;code>cpputest&lt;/code>, because it looks better.&lt;/p>
&lt;p>tests/meson.build:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>cpputest_project &lt;span style="color:#f92672">=&lt;/span> subproject(&lt;span style="color:#e6db74">&amp;#39;cpputest&amp;#39;&lt;/span>, required: &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpputest &lt;span style="color:#f92672">=&lt;/span> cpputest_project.get_variable(&lt;span style="color:#e6db74">&amp;#39;cpputest_dep&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;calc&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;greeter&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tests/calc/meson.build:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>calc_test_exec &lt;span style="color:#f92672">=&lt;/span> executable(&lt;span style="color:#e6db74">&amp;#39;calc_test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test.cpp&amp;#39;&lt;/span>, dependencies: cpputest)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test(&lt;span style="color:#e6db74">&amp;#39;calc test&amp;#39;&lt;/span>, calc_test_exec)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we should also be able to run our test via &lt;code>meson test&lt;/code> command.&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; meson test -C builddir
ninja: Entering directory `\builddir&amp;#39;
ninja: no work to do.
1/1 calc test FAIL 0.01s exit status 1
&amp;gt;&amp;gt;&amp;gt; MALLOC_PERTURB_=245 ASAN_OPTIONS=halt_on_error=1:abort_on_error=1:print_summary=1 UBSAN
_OPTIONS=halt_on_error=1:abort_on_error=1:print_summary=1:print_stacktrace=1 \builddir\tests\calc\calc_test.exe
Ok: 0
Expected Fail: 0
Fail: 1
Unexpected Pass: 0
Skipped: 0
Timeout: 0
Full log written to \builddir\meson-logs\testlog.txt
&lt;/code>&lt;/pre>&lt;p>It will fail, because in the previous part we&amp;rsquo;ve written a test that should fail, so it&amp;rsquo;s all good.
Your &lt;code>MALLOC_PERTURB_&lt;/code> may be different, as it&amp;rsquo;s randomly chosen every test run.
It&amp;rsquo;s used for some magic involving &lt;code>malloc&lt;/code> that helps detecting memory-related issues.&lt;/p>
&lt;p>So, it seems like we have a working unit test setup.
Let&amp;rsquo;s write some meaningful tests for both modules and we&amp;rsquo;ll check if we can call them separately.
We also have to finish up our Meson script for &lt;code>calc&lt;/code> test, because we&amp;rsquo;re not linking to &lt;code>calc&lt;/code> yet, and we should!
And we also have to add &lt;code>libs_includes&lt;/code> to includes for our test exec.&lt;/p>
&lt;p>tests/calc/meson.build&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>calc_test_exec &lt;span style="color:#f92672">=&lt;/span> executable(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;calc_test&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sources: &lt;span style="color:#e6db74">&amp;#39;test.cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies: cpputest,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with: calc_lib,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_directories: libs_includes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test(&lt;span style="color:#e6db74">&amp;#39;calc test&amp;#39;&lt;/span>, calc_test_exec)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And our test may look like this:&lt;/p>
&lt;p>tests/calc/test.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;CppUTest/CommandLineTestRunner.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;CppUTest/TestHarness.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;calc/calc.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST_GROUP(TemperatureCalcTests){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST(TemperatureCalcTests, convertsCelciusToFahrenheit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> givenCelcius &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">37.7778&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> expectedFahrenheit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> gotFahrenheit &lt;span style="color:#f92672">=&lt;/span> celcius_to_fahrenheit(givenCelcius);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DOUBLES_EQUAL(expectedFahrenheit, gotFahrenheit, &lt;span style="color:#ae81ff">0.001&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST(TemperatureCalcTests, convertsFahrenheitToCelcius) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> givenFahrenheit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">212&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> expectedCelcius &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">100.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> gotCelcius &lt;span style="color:#f92672">=&lt;/span> fahrenheit_to_celcius(givenFahrenheit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DOUBLES_EQUAL(expectedCelcius, gotCelcius, &lt;span style="color:#ae81ff">0.001&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> ac, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> av) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> CommandLineTestRunner&lt;span style="color:#f92672">::&lt;/span>RunAllTests(ac, av);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We should create similar meson and source file for greeter.&lt;/p>
&lt;p>tests/greeter/meson.build&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>greeter_test_exec &lt;span style="color:#f92672">=&lt;/span> executable(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;greeter_test&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sources: &lt;span style="color:#e6db74">&amp;#39;test.cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies: cpputest,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with: greeter_lib,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_directories: libs_includes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test(&lt;span style="color:#e6db74">&amp;#39;greeter test&amp;#39;&lt;/span>, greeter_test_exec)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tests/greeter/test.cpp&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;CppUTest/CommandLineTestRunner.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;CppUTest/TestHarness.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;greeter/greeter.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST_GROUP(GreeterTests){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST(GreeterTests, greetsUser) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string(&lt;span style="color:#e6db74">&amp;#34;user&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> expectedMessage &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string(&lt;span style="color:#e6db74">&amp;#34;Hello user&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> actualMessage &lt;span style="color:#f92672">=&lt;/span> greet(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CHECK_EQUAL(expectedMessage, actualMessage);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> ac, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> av) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> CommandLineTestRunner&lt;span style="color:#f92672">::&lt;/span>RunAllTests(ac, av);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now, after running &lt;code>meson test -C builddir&lt;/code>, we should get something like this:&lt;/p>
&lt;pre tabindex="0">&lt;code>PS .&amp;gt; meson test -C builddir
ninja: Entering directory `.\builddir&amp;#39;
ninja: no work to do.
1/2 calc test OK 0.01s
2/2 greeter test OK 0.01s
Ok: 2
Expected Fail: 0
Fail: 0
Unexpected Pass: 0
Skipped: 0
Timeout: 0
Full log written to .\builddir\meson-logs\testlog.txt
&lt;/code>&lt;/pre>&lt;p>And here we go, we finally have working unit tests in our project.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>Oh well, this part took way too long to publish.
I blame Helldivers II for that.
To be fair, I finished writing it in a manner of two weeks, I just didn&amp;rsquo;t have energy to finish it and push it.
Still, I&amp;rsquo;m gonna try to move it forward faster because my backlog of stuff to do is incredibly long, and this template could help.
For anyone interesed, &lt;a href="https://github.com/SteelPh0enix/meson_c_cpp_project_template/releases/tag/part-2">there&amp;rsquo;s a tag&lt;/a> in the repository with it&amp;rsquo;s current state.
In the next part, i will show you how to configure Doxygen with Meson to generate documentation of our modules and applications functions.&lt;/p></content></item><item><title>Making C/C++ project template in Meson - part 2</title><link>https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2/</link><pubDate>Wed, 07 Feb 2024 00:00:00 +0000</pubDate><guid>https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-2/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>In &lt;a href="https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-1/">previous part&lt;/a>, we&amp;rsquo;ve created the base of our project by defining it&amp;rsquo;s structure and making our first modules and executable.
In this one, we&amp;rsquo;re gonna add unit tests support.&lt;/p>
&lt;p>But before that&amp;hellip;&lt;/p>
&lt;h3 id="fixing-our-mistakes">Fixing our mistakes&lt;/h3>
&lt;p>So, uhh, let&amp;rsquo;s look at our project.
Specifically, at our &lt;code>hello_world.cpp&lt;/code>.
More specifically, at includes.
It&amp;rsquo;s not that something is wrong with them &lt;em>right now&lt;/em>, but think about it - what would happen if we&amp;rsquo;d put an &lt;code>utils.hpp&lt;/code> file in both libraries?
That is actually a question that can be answered using the &amp;ldquo;fuck around and find out&amp;rdquo; method, so let&amp;rsquo;s find out.&lt;/p></description><content>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>In &lt;a href="https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-1/">previous part&lt;/a>, we&amp;rsquo;ve created the base of our project by defining it&amp;rsquo;s structure and making our first modules and executable.
In this one, we&amp;rsquo;re gonna add unit tests support.&lt;/p>
&lt;p>But before that&amp;hellip;&lt;/p>
&lt;h3 id="fixing-our-mistakes">Fixing our mistakes&lt;/h3>
&lt;p>So, uhh, let&amp;rsquo;s look at our project.
Specifically, at our &lt;code>hello_world.cpp&lt;/code>.
More specifically, at includes.
It&amp;rsquo;s not that something is wrong with them &lt;em>right now&lt;/em>, but think about it - what would happen if we&amp;rsquo;d put an &lt;code>utils.hpp&lt;/code> file in both libraries?
That is actually a question that can be answered using the &amp;ldquo;fuck around and find out&amp;rdquo; method, so let&amp;rsquo;s find out.&lt;/p>
&lt;p>This is the content of our &lt;code>utils.hpp&lt;/code>.
Adjust the returned string appropriately for the other module.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pragma once
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string what_am_i() { &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string(&lt;span style="color:#e6db74">&amp;#34;i am calc&amp;#34;&lt;/span>); }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, our new &lt;code>hello_world.cpp&lt;/code> will become this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;calc.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;greeter.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;utils.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> greet(what_am_i()) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;12.5*F == &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> fahrenheit_to_celcius(&lt;span style="color:#ae81ff">12.5&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*C&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;12.5*C == &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> celcius_to_fahrenheit(&lt;span style="color:#ae81ff">12.5&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*F&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aaand&amp;hellip; In my case, it prints &lt;code>Hello i am calc&lt;/code>, which is caused by the fact that &lt;code>calc_includes&lt;/code> are before &lt;code>greeter_includes&lt;/code> in my &lt;code>hello_world/meson.build&lt;/code>&amp;rsquo;s &lt;code>executable()&lt;/code> call.
After swapping them, &lt;code>Hello i am greeter&lt;/code> is printed.&lt;/p>
&lt;p>Now that we know what happens, we can easily deduce that it&amp;rsquo;s not supposed to work like that - because we don&amp;rsquo;t have a reasonable way to access the other &lt;code>utils.hpp&lt;/code>.
The simplest solution is to move the include directory one level up, to &lt;code>lib&lt;/code> directory.
And in retrospect, that&amp;rsquo;s how it should be done from the beginning, so excuse my blunder there.&lt;/p>
&lt;p>In order to fix our mistake, we have to revisit some &lt;code>meson.build&lt;/code> files.
First, let&amp;rsquo;s create an include directory object in &lt;code>lib/meson.build&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>libs_includes &lt;span style="color:#f92672">=&lt;/span> include_directories(&lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;calc&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;greeter&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I&amp;rsquo;ve added it before the &lt;code>subdir()&lt;/code> calls just in case some modules would depend on each other.
This is not something we want to do often, because for every dependency we will probably have to create a mock in order to properly test the modules that use them, but it&amp;rsquo;s sometimes necessary.&lt;/p>
&lt;p>After that, remove the &lt;code>include_directories()&lt;/code> calls from &lt;code>greeter&lt;/code> and &lt;code>calc&lt;/code> modules &lt;code>meson.build&lt;/code>, and fix the &lt;code>executable()&lt;/code> call arguments in &lt;code>hello_world/meson.build&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>hello_world &lt;span style="color:#f92672">=&lt;/span> executable(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;hello_world&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;hello_world.cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with: [calc_lib, greeter_lib],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_directories: [libs_includes],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And fix the includes in &lt;code>hello_world.cpp&lt;/code>.
We can also remove the &lt;code>utils.hpp&lt;/code> and restore the original &lt;code>hello_world.cpp&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;calc/calc.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;greeter/greeter.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> greet(&lt;span style="color:#e6db74">&amp;#34;random developer&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;12.5*F == &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> fahrenheit_to_celcius(&lt;span style="color:#ae81ff">12.5&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*C&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;12.5*C == &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> celcius_to_fahrenheit(&lt;span style="color:#ae81ff">12.5&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*F&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Also; let&amp;rsquo;s rename our &lt;code>lib/&lt;/code> directory to &lt;code>libs/&lt;/code>, this is a very small change but my brain automatically tries to write &lt;code>libs/&lt;/code> instead of &lt;code>lib/&lt;/code> because there are &lt;em>multiple&lt;/em> libraries there, so I think it reflects this directory&amp;rsquo;s content better.
Remember to also change the argument of &lt;code>subdir()&lt;/code> in the root &lt;code>meson.build&lt;/code>.&lt;/p>
&lt;p>Verify if the project still builds and the executable still works. Remove the &lt;code>builddir&lt;/code> first, as we made pretty big change and I honestly don&amp;rsquo;t expect Meson to correctly re-generate it.&lt;/p>
&lt;h2 id="harnessing-the-power-of-unit-tests">Harnessing the power of unit tests&lt;/h2>
&lt;p>I want to assume that You have at least minimal experience with testing your code, but i know some people who don&amp;rsquo;t, so i will not.
But I&amp;rsquo;ll also try not to over explain, there are other resources for that.
If you already know a thing or two about unit testing, you can ignore the rest of this chapter.
Or maybe don&amp;rsquo;t, maybe you&amp;rsquo;ll learn something new.
I dunno.&lt;/p>
&lt;p>When You write some code, it&amp;rsquo;s usually a good habit to test it.
After all, &lt;em>how do you know if the code working correctly?&lt;/em>
You run it, and see if it does what it&amp;rsquo;s supposed to.
The simplest way of doing that is writing some small programs that use the code in question in various ways, and check if the outputs of this code are correct.
For example, let&amp;rsquo;s assume you&amp;rsquo;ve written a function that calculates the amount of damage an attack does in an RPG game.
To test it, You can create some attack scenarios with various items, statistics, and whatever else can influence damage.
Then, calculate the results manually beforehand, and write the code that will perform those calculations using that function and verify if they match your calculations.
Tests that verify those small pieces of code, like functions or classes, are usually called &lt;strong>unit tests&lt;/strong>.
The most basic unit test can be something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;assert.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;DamageCalculation.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;test_utils.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Weapon &lt;span style="color:#66d9ef">const&lt;/span> weapon &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">create_test_weapon&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Enemy &lt;span style="color:#66d9ef">const&lt;/span> enemy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">create_test_enemy&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#a6e22e">calculate_damage&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>weapon, &lt;span style="color:#f92672">&amp;amp;&lt;/span>enemy) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">3.14&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Although I&amp;rsquo;d replace that magic number with some very approximate manual calculation, if possible.
Tests should not be cryptic - this is, but only because it&amp;rsquo;s an unspecified example.&lt;/p>
&lt;p>Fortunately, the humanity have &lt;em>(mostly)&lt;/em> progressed past the need for &lt;code>assert&lt;/code>, and invented &lt;strong>test harnesses&lt;/strong> that are &lt;em>(usually)&lt;/em> less painful to use.
Trust me on that.
Even C guys didn&amp;rsquo;t like rawdogging &lt;code>assert&lt;/code>, and jumped on &lt;a href="http://www.throwtheswitch.org/unity">Unity&lt;/a> (not &lt;a href="https://www.axios.com/2023/09/22/unity-apologizes-runtime-fees">&lt;em>that&lt;/em>&lt;/a> Unity) and other similar &amp;ldquo;wrappers&amp;rdquo;.
In any case, using a test harness is easier than making one ourselves (or not using one at all), so we are going to use one.
I&amp;rsquo;d prefer if it also were multi-platform and supported both C and C++, and fortunately we have some options in the open-source market for that.&lt;/p>
&lt;h2 id="managing-external-dependencies-with-meson">Managing external dependencies with Meson&lt;/h2>
&lt;p>Before we choose a test harness, however, let&amp;rsquo;s check how Meson handles external dependencies.
Fortunately, &lt;a href="https://mesonbuild.com/Dependencies.html">documentation&lt;/a> got us covered.
And it seems that Meson supports &lt;em>a lot&lt;/em> of popular libraries in very specific ways, which is very, very nice.
However, the &lt;code>dependency()&lt;/code> function seems to work only for locally available packages, which would usually mean that we have to manually download and set up the libraries for development each time we set up a new project environment - but there&amp;rsquo;s a nice catch!
Meson also provides &lt;a href="https://mesonbuild.com/Wrap-dependency-system-manual.html">&lt;strong>Wrap dependency system&lt;/strong>&lt;/a>.
I recommend reading the linked documentation, but if you want a TL;DR: this is a package manager.
Sort of.
You put a valid &lt;code>.wrap&lt;/code> file in &lt;code>subprojects/&lt;/code> directory and voila, Meson can download and build the dependency, allowing us to use it in our project - automagically.&lt;/p>
&lt;p>After looking at available &lt;a href="https://mesonbuild.com/Wrapdb-projects.html">wraps&lt;/a>, and considering the fact that I&amp;rsquo;d like to use that template for ARM projects, I have decided I&amp;rsquo;m going with &lt;a href="https://github.com/cpputest/cpputest">CppUTest&lt;/a>.
If you want to try another test harness, feel free to do that and experiment - but keep in mind that the setup process may vary a bit, depending on the library needs.
CppUTest is relatively simple, which is nice if you&amp;rsquo;re looking for something without much complexity, but it won&amp;rsquo;t provide as many features as some other harnessed - like &lt;a href="https://github.com/catchorg/Catch2">Catch2&lt;/a> or &lt;a href="https://github.com/google/googletest">Google Test&lt;/a>.
I like simple, and it should probably make porting everything to ARM easier, so I&amp;rsquo;m going with CppUTest.&lt;/p>
&lt;p>Let&amp;rsquo;s create &lt;code>subprojects/&lt;/code> directory and run &lt;code>meson wrap install cpputest&lt;/code> (or your preferred test harness).
Installation should proceed automatically, and &lt;code>subprojects/cpputest.wrap&lt;/code> file should appear.
Then, to use it, we have to declare a &lt;code>subproject()&lt;/code> in one of our &lt;code>meson.build&lt;/code> files.
Let&amp;rsquo;s do that in our &lt;code>tests/meson.build&lt;/code>.
We&amp;rsquo;ll also add our tests subdirectories, since we&amp;rsquo;re already editing that file.
Add them below the &lt;code>subproject()&lt;/code> to make sure the test harness is available there.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>cpputest_project &lt;span style="color:#f92672">=&lt;/span> subproject(&lt;span style="color:#e6db74">&amp;#39;cpputest&amp;#39;&lt;/span>, required: &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cpputest_dependency &lt;span style="color:#f92672">=&lt;/span> cpputest_project.get_variable(&lt;span style="color:#e6db74">&amp;#39;cpputest_dep&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;calc&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;greeter&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we also have to declare &lt;code>tests&lt;/code> directory as a &lt;code>subdir()&lt;/code> in main &lt;code>meson.build&lt;/code>.
I&amp;rsquo;ve put it after &lt;code>apps&lt;/code>, because integration tests may require built apps as dependencies to run.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;libs&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;apps&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;tests&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, we can check if this works by deleting &lt;code>builddir&lt;/code>, and running &lt;code>meson setup builddir&lt;/code> and &lt;code>meson compile -C builddir&lt;/code>.
You should see some new logs after running &lt;code>setup&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>Executing subproject cpputest
cpputest| Project name: cpputest
cpputest| Project version: 4.0
cpputest| C++ compiler for the host machine: ccache c++ (gcc 13.2.0 &amp;#34;c++ (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 13.2.0&amp;#34;)
cpputest| C++ linker for the host machine: c++ ld.bfd 2.41
cpputest| Build targets in project: 5
cpputest| Subproject cpputest finished.
Build targets in project: 5
project_template 0.1
Subprojects
cpputest: YES
&lt;/code>&lt;/pre>&lt;p>That tells us Meson found the wrap and should&amp;rsquo;ve downloaded it.
Compilation should also take significantly longer, because our test harness must be compiled for the first time.
If that&amp;rsquo;s the case, our first step is done.
Now, we have to actually write a test.
Create &lt;code>test.cpp&lt;/code> file in &lt;code>tests/calc/&lt;/code> and put this there:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;CppUTest/CommandLineTestRunner.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;CppUTest/TestHarness.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST_GROUP(FirstTestGroup){};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TEST(FirstTestGroup, FirstTest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FAIL(&lt;span style="color:#e6db74">&amp;#34;Fail me!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> ac, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> av) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> CommandLineTestRunner&lt;span style="color:#f92672">::&lt;/span>RunAllTests(ac, av);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, let&amp;rsquo;s make it compile. Open &lt;code>tests/calc/meson.build&lt;/code> and put it there:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>calc_test_exec &lt;span style="color:#f92672">=&lt;/span> executable(&lt;span style="color:#e6db74">&amp;#39;calc_test&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test.cpp&amp;#39;&lt;/span>, dependencies: cpputest_dependency)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test(&lt;span style="color:#e6db74">&amp;#39;calc test&amp;#39;&lt;/span>, calc_test_exec)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In theory, this should build just fine.
However, in practice&amp;hellip;&lt;/p>
&lt;pre tabindex="0">&lt;code>[44/44] Linking target tests/calc/calc_test.exe
FAILED: tests/calc/calc_test.exe
&amp;#34;c++&amp;#34; -o tests/calc/calc_test.exe tests/calc/calc_test.exe.p/test.cpp.obj &amp;#34;-Wl,--allow-shlib-undefined&amp;#34; &amp;#34;-Wl,--start-group&amp;#34; &amp;#34;subprojects/cpputest-4.0/src/CppUTestExt/libCppUTestExt.a&amp;#34; &amp;#34;-Wl,--subsystem,console&amp;#34; &amp;#34;-lkernel32&amp;#34; &amp;#34;-luser32&amp;#34; &amp;#34;-lgdi32&amp;#34; &amp;#34;-lwinspool&amp;#34; &amp;#34;-lshell32&amp;#34; &amp;#34;-lole32&amp;#34; &amp;#34;-loleaut32&amp;#34; &amp;#34;-luuid&amp;#34; &amp;#34;-lcomdlg32&amp;#34; &amp;#34;-ladvapi32&amp;#34; &amp;#34;-Wl,--end-group&amp;#34;
C:/gcc/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: tests/calc/calc_test.exe.p/test.cpp.obj: in function `TEST_FirstTestGroup_FirstTest_Test::testBody()&amp;#39;:
F:\Projects\C_C++\meson_c_cpp_project_template\builddir/../tests/calc/test.cpp:7:(.text+0x11): undefined reference to `UtestShell::getCurrent()&amp;#39;
&lt;/code>&lt;/pre>&lt;p>In practice, I get a massive linking error.
Gee, I wonder why.&lt;/p>
&lt;p>After few minutes of investigation, I&amp;rsquo;ve reached the conclusion: the &lt;em>&amp;ldquo;official&amp;rdquo;&lt;/em> CppUTest wrap is &lt;strong>very bad&lt;/strong>.
And by that, I mean it&amp;rsquo;s completely broken.
If you&amp;rsquo;ve used a different test harness, and it works (i know for a fact that Catch2 should, last i tried at least&amp;hellip;) - congratulations, you can skip the next part!
For the rest of you, don&amp;rsquo;t worry - we&amp;rsquo;re fix that issue. It&amp;rsquo;ll just take a bit longer for you, and much longer for me.&lt;/p>
&lt;h2 id="side-quest---fixing-cpputest">Side quest - fixing CppUTest!&lt;/h2>
&lt;p>Let&amp;rsquo;s look at it&amp;rsquo;s build files, as everything is stored in &lt;code>subprojects/cpputest-4.0&lt;/code>.
First thing that I&amp;rsquo;ve noticed was spelling error - the author used &lt;code>extinctions&lt;/code> instead of &lt;code>extensions&lt;/code> (in multiple places, so this was&amp;hellip; Intentional?)
Then, I&amp;rsquo;ve noticed something worse.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>cpputest_dep &lt;span style="color:#f92672">=&lt;/span> declare_dependency(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with : cpputest_lib,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version : meson.project_version(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_directories : cpputest_dirs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> get_option(&lt;span style="color:#e6db74">&amp;#39;extinctions&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpputest_dep &lt;span style="color:#f92672">=&lt;/span> declare_dependency(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with : cpputest_ext_lib,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version : meson.project_version(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_directories : cpputest_dirs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You see this, right?
Obviously, a typo, someone forgot to add &lt;code>_ext&lt;/code>, but one that completely breaks the wrap.
Extensions are enabled by default, by the way.
See &lt;code>meson_options.txt&lt;/code> in CppUTest directory:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>option(&lt;span style="color:#e6db74">&amp;#39;extinctions&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type : &lt;span style="color:#e6db74">&amp;#39;boolean&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value : &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description : &lt;span style="color:#e6db74">&amp;#39;Use the CppUTest extension library&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, what happens when we fix that? We can do it pretty easily, just declare a second dependency, we don&amp;rsquo;t even have to link the extensions because at this point we&amp;rsquo;re not using them.
Rename &lt;code>cpputest_dep&lt;/code> for extensions to &lt;code>cpputest_ext_dep&lt;/code> and let&amp;rsquo;s add the second dependency to &lt;code>cpputest.wrap&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> get_option(&lt;span style="color:#e6db74">&amp;#39;extinctions&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpputest_ext_dep &lt;span style="color:#f92672">=&lt;/span> declare_dependency(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with : cpputest_ext_lib,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version : meson.project_version(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_directories : cpputest_dirs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>[provide]
cpputest = cpputest_dep
cpputest_ext = cpputest_ext_dep
&lt;/code>&lt;/pre>&lt;p>And after clean compilation, unfortunately, this doesn&amp;rsquo;t solve my issue.
I get multiple undefined references to platform-related functions, because apparently someone forgot to add platform-specific implementations that CppUTest provides as dependencies&amp;hellip;&lt;/p>
&lt;p>Well, the fix is &lt;em>easy&lt;/em> - I just have to make a proper wrap myself.
To be continued, after I make it working.&lt;/p>
&lt;blockquote>
&lt;p>Yeah, I could jump the ship and just use different library, but &lt;em>where&amp;rsquo;s the fun in that?&lt;/em>
I&amp;rsquo;ve already vibe checked that one.
Also; there is no tag in the repository for now, I&amp;rsquo;m gonna make one after making that wrap and finishing up this part in next post(s).&lt;/p>
&lt;/blockquote></content></item><item><title>Making C/C++ project template in Meson - part 1</title><link>https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-1/</link><pubDate>Sat, 27 Jan 2024 00:00:00 +0000</pubDate><guid>https://steelph0enix.github.io/posts/making-c-cpp-project-template-in-meson-part-1/</guid><description>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>One of the things that I dislike about C and C++ in particular is lack of standardized build environment, package manager, and all that stuff.
And although CMake is de-facto &amp;ldquo;standard&amp;rdquo; over here, and even tries to double as a &amp;ldquo;package manager&amp;rdquo;, I find it hard to like this tool.
It&amp;rsquo;s not a &lt;em>bad&lt;/em> tool, I&amp;rsquo;ve used it few times, I&amp;rsquo;ve seen some non-trivial projects made with CMake, but I did not like what I&amp;rsquo;ve seen.&lt;/p></description><content>&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>One of the things that I dislike about C and C++ in particular is lack of standardized build environment, package manager, and all that stuff.
And although CMake is de-facto &amp;ldquo;standard&amp;rdquo; over here, and even tries to double as a &amp;ldquo;package manager&amp;rdquo;, I find it hard to like this tool.
It&amp;rsquo;s not a &lt;em>bad&lt;/em> tool, I&amp;rsquo;ve used it few times, I&amp;rsquo;ve seen some non-trivial projects made with CMake, but I did not like what I&amp;rsquo;ve seen.&lt;/p>
&lt;p>I&amp;rsquo;ve also been missing a proper C/C++ project template for a very long time.
I was not aware I&amp;rsquo;m missing one, until i got a hang of the codebase of one of the projects I&amp;rsquo;ve been working on in my work, and experienced the true power of scripting and automation.
I&amp;rsquo;ve been tinkering with many build systems over the years, but I&amp;rsquo;ve never found one that really &amp;ldquo;clicked&amp;rdquo; for me.
And since I still cannot lift the curse of C/C++ from my life, it seems the only alternative I have is to pick &lt;em>something&lt;/em> and force myself through.
And I&amp;rsquo;m taking You for a ride with me.&lt;/p>
&lt;p>So we&amp;rsquo;re going with &lt;a href="https://mesonbuild.com/">Meson Build system&lt;/a>, which was recommended to me by a colleague few years ago.
Since then I&amp;rsquo;ve read the docs and also experimented with it a bit, but I haven&amp;rsquo;t really made a proper project based on it yet, as of writing this sentence.
This is about to change.&lt;/p>
&lt;p>I will try to make this series of blog posts as &amp;ldquo;followable&amp;rdquo; as possible, so You should be able to reproduce most of my work by yourself, and understand the choices I make.
Remember that the best tool for the job is sometimes the one you make yourself, not the one you blindly copy&amp;amp;paste without deeper understanding.
&lt;del>But please, don&amp;rsquo;t reinvent the wheel if that&amp;rsquo;s not necessary.&lt;/del>
&lt;del>Use the right tools for the job, and whatnot.&lt;/del>&lt;/p>
&lt;h2 id="goals">Goals&lt;/h2>
&lt;p>Our main goal here is to &lt;strong>make a generic, compiler/platform-independent, easy-to-expand project template in Meson for small-to-medium size C/C++ projects&lt;/strong>.
I also want it to have some specific features that I believe are &amp;ldquo;must have&amp;rdquo; in any self-respecting project.
In the end, we will use that template to write some kind of application and maybe play with the project&amp;rsquo;s structure afterwards, until I&amp;rsquo;m satisfied with the results.
After that, I have a plan to use this template as a basis for ARM Cortex-M project template, but we&amp;rsquo;ll cross that bridge when we&amp;rsquo;ll get to it.&lt;/p>
&lt;p>The first thing that I&amp;rsquo;m interested in is unit and integration test support.
I don&amp;rsquo;t want to make assumptions about test harnesses though, so we&amp;rsquo;ll just have to make sure that the project&amp;rsquo;s structure is &lt;em>testable&lt;/em> and Meson can build the tests.
Unit tests have built-in support in Meson, so let&amp;rsquo;s go with that.
There&amp;rsquo;s also some support for code coverage, and we will surely explore that too.
Integration tests are much more project-dependent, so the only requirements is that Meson should recognize them as targets, but running them might be done via external script or program (executed by Meson).
Meson is our &lt;em>build&lt;/em> system, not necessarily the runner, nor the harness, so let&amp;rsquo;s not expect it to be able to handle generic integration tests by itself.
Some external tooling/scripting may still be required (especially when we&amp;rsquo;ll get to the embedded part&amp;hellip;), but everything should eventually be held together by Meson.&lt;/p>
&lt;p>The second thing that I wanna see there is support for C/C++ LSP.
My primary choice there is &lt;code>clangd&lt;/code>, so we&amp;rsquo;ll have to generate &lt;code>compile_commands.json&lt;/code> using Meson. Fortunately, it does that automatically.&lt;/p>
&lt;p>The third thing is support for code checks and code formatting.
External tools can be plugged to Meson via &lt;a href="https://mesonbuild.com/Custom-build-targets.html">custom build targets&lt;/a>, and we will configure at least one code checker and autoformatter like that.
Our project should provide commands to perform project-wide code and formatting check (which is very useful in git prehooks).&lt;/p>
&lt;p>And the last, but not the least - documentation.
I want to be able to generate docs for my code via Meson.
Probably using Doxygen, as it&amp;rsquo;s relatively easy to set up.
This also includes coverage reports, and we will most likely use &lt;code>lcov&lt;/code>/&lt;code>gcov&lt;/code> for that.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Did I mention that I&amp;rsquo;ve spent most of last year writing Rust code?&lt;/em>
&lt;em>Did you know that Cargo provides most of the stuff that I&amp;rsquo;ve described here out-of-the-box?&lt;/em>
&lt;em>Now you do.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;h2 id="preparations">Preparations&lt;/h2>
&lt;p>Before we start, let&amp;rsquo;s check our prerequisites, because there&amp;rsquo;s gonna be some.&lt;/p>
&lt;ul>
&lt;li>Meson - on Linux, should be in your package manager. If it&amp;rsquo;s not, i assume you know what to do. On Windows, i recommend grabbing an installer from &lt;a href="https://github.com/mesonbuild/meson/releases">Github&lt;/a>. Just make sure it&amp;rsquo;s in your &lt;code>PATH&lt;/code> variable - check if opening a terminal and running &lt;code>meson --version&lt;/code> returns expected version string. I&amp;rsquo;m currently running 1.3.1. &lt;em>Technically Meson is available via &lt;code>winget&lt;/code>, but their repo currently provides outdated version, so i recommend installing it manually on Windows.&lt;/em>&lt;/li>
&lt;li>Ninja - I&amp;rsquo;ll describe it&amp;rsquo;s purpose in a bit. It should be bundled with Meson on Windows, and should be installed automatically on Linux when installing Meson via package manager. Should be in your &lt;code>PATH&lt;/code> too. In any case, verify if it&amp;rsquo;s installed correctly by running &lt;code>ninja --version&lt;/code>. I&amp;rsquo;m currently running 1.11.1. You can also install it manually if needed &lt;a href="https://github.com/ninja-build/ninja/releases">by downloading a zip from Github&lt;/a> and extracting it into a directory that&amp;rsquo;s in &lt;code>PATH&lt;/code> variable.&lt;/li>
&lt;li>C/C++ toolchain - &lt;strong>TL;DR install latest GCC&lt;/strong>. In theory, we don&amp;rsquo;t have to choose any specific toolchain, because we&amp;rsquo;re using Meson and Ninja which support the popular ones. &lt;strong>However&lt;/strong>, I&amp;rsquo;ve mentioned that I want to have coverage report generation, and the only coverage tools that I&amp;rsquo;m familiar with are &lt;code>lcov&lt;/code>/&lt;code>gcov&lt;/code>, and this pretty much forces me to use GCC. If you don&amp;rsquo;t care about code coverage reports, pick your treat. If you somehow got here as a complete newbie and you don&amp;rsquo;t have any C/C++ toolchain installed, either grab GCC from your package manager if you&amp;rsquo;re running Linux (look for package called &lt;code>build-essentials&lt;/code> or &lt;code>base-devel&lt;/code> or something like that), or - if you&amp;rsquo;re running Windows - &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#cc-toolchain">download latest WinLibs package and add it&amp;rsquo;s &lt;code>bin&lt;/code> subdirectory to PATH&lt;/a>. Or install Microsoft&amp;rsquo;s Visual C++ toolchain via Visual Studio Build Tools (you may need to do that even after installing WinLibs, if you want to use &lt;code>clang&lt;/code>, but I recommend &lt;strong>not&lt;/strong> using MSVC for pure C unless you don&amp;rsquo;t value your sanity).&lt;/li>
&lt;li>LLVM tools - mostly &lt;code>clangd&lt;/code>, but we&amp;rsquo;re also gonna use &lt;code>clang-tidy&lt;/code> at some point. If you&amp;rsquo;re running Linux, again - find those tools in your package manager. If you&amp;rsquo;re running Windows and WinLibs, you already got them. If you don&amp;rsquo;t use WinLibs, install latest LLVM release (&lt;code>winget install llvm&lt;/code>, should be &amp;ldquo;recent enough&amp;rdquo;, or get it from &lt;a href="https://github.com/llvm/llvm-project/releases">Github&lt;/a>), it should contain everything we&amp;rsquo;ll need. Again, if manually installed - make sure it&amp;rsquo;s in PATH by running &lt;code>clangd --version&lt;/code>. I&amp;rsquo;m currently using 17.0.5.&lt;/li>
&lt;li>Doxygen - we&amp;rsquo;re not gonna be using it any time soon, but let&amp;rsquo;s make sure it&amp;rsquo;s available. Linux - install from repo, Windows - it&amp;rsquo;s already in WinLibs, if not using WinLibs (or you want the latest version), install manually - &lt;code>winget install doxygen&lt;/code> or grab installer from &lt;a href="https://www.doxygen.nl/download.html">here&lt;/a>. Run &lt;code>doxygen --version&lt;/code> to verify, I&amp;rsquo;m using 1.10.0. &lt;strong>Note - Winget may not add it to PATH, it&amp;rsquo;s installed in &lt;code>Program Files/doxygen&lt;/code> by default. Add &lt;code>bin&lt;/code> subdirectory to &lt;code>PATH&lt;/code> manually if that&amp;rsquo;s the case.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Oh, and there&amp;rsquo;s a small issue of &lt;code>lcov&lt;/code> not having official Windows support. There are some unofficial releases, but we&amp;rsquo;re not gonna use them - instead, we&amp;rsquo;re gonna lock the coverage report generation feature to Linux and GCC only.
I don&amp;rsquo;t want to completely lock this template to GCC because of that feature, so we will have to separate this part appropriately.&lt;/p>
&lt;blockquote>
&lt;p>We can always use containers to get this running with all features on Windows.&lt;/p>
&lt;/blockquote>
&lt;p>Also; i &lt;em>assume&lt;/em> that we&amp;rsquo;re gonna be using Ninja as our building &amp;ldquo;back-end&amp;rdquo;, but it doesn&amp;rsquo;t really matter because Meson should handle whatever &amp;ldquo;back-end&amp;rdquo; you&amp;rsquo;d like to use.
Just make sure to check the &amp;ldquo;whatever &amp;ldquo;back-end&amp;rdquo; you&amp;rsquo;d like to use&amp;rdquo; output when I&amp;rsquo;m talking about Ninja output.
This is an &amp;ldquo;I assume you know what you&amp;rsquo;re doing&amp;rdquo; warning.&lt;/p>
&lt;h2 id="hello-world">Hello, world!&lt;/h2>
&lt;p>Assuming that everything is installed, we are ready to get going.
I&amp;rsquo;ve made a &lt;a href="https://github.com/SteelPh0enix/meson_c_cpp_project_template">repository&lt;/a> for this project, I&amp;rsquo;ll try to make a tag after each part so You can easily follow.&lt;/p>
&lt;p>Let&amp;rsquo;s start by initializing a new Meson project in an empty directory.
The arguments don&amp;rsquo;t really matter here - we&amp;rsquo;re gonna be building our &lt;code>meson.build&lt;/code> from scratch anyway, but right now we want to verify if our environment is set up correctly, so let&amp;rsquo;s go with those for now:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>meson init --name project_template --language cpp --type executable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This should generate two files - &lt;code>meson.build&lt;/code> and &lt;code>project_template.cpp&lt;/code>. &lt;code>meson.build&lt;/code> should contain project definition with some reasonable defaults, executable, and a test:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>project(&lt;span style="color:#e6db74">&amp;#39;project_template&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version : &lt;span style="color:#e6db74">&amp;#39;0.1&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> default_options : [&lt;span style="color:#e6db74">&amp;#39;warning_level=3&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;cpp_std=c++14&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exe &lt;span style="color:#f92672">=&lt;/span> executable(&lt;span style="color:#e6db74">&amp;#39;project_template&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;project_template.cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install : &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test(&lt;span style="color:#e6db74">&amp;#39;basic&amp;#39;&lt;/span>, exe)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Source file should contain a very simple test program:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define PROJECT_NAME &amp;#34;project_template&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(argc &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> argv[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;takes no arguments.&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;This is project &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> PROJECT_NAME &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;.&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s try building it.
But first, we need to generate actual build scripts via Meson, as it&amp;rsquo;s (similarly to CMake) a meta-build system.
Which means that it&amp;rsquo;s only a &lt;em>generator&lt;/em> for an actual build system (like Ninja, or GNU Make) that performs the heavy lifting.
If you&amp;rsquo;re not used to this approach, it may make no sense at first - why use two tools instead of one, right?
Unfortunately, building stuff is not easy in C/C++, especially when you&amp;rsquo;re working on a big project with multiple dependencies, that must be supported on many different platforms.
As far as I know, the earliest successful application of this approach is &lt;a href="https://en.wikipedia.org/wiki/GNU_Autotools">GNU Autotools&lt;/a> project with it&amp;rsquo;s &lt;code>configure&lt;/code>-&lt;code>make&lt;/code>-&lt;code>make install&lt;/code> routine.
Apparently, it&amp;rsquo;s good to have an additional layer of abstraction over the target build system.
I have already mentioned some reasons for that (multi-platform, yadda yadda yadda), also - meta-build systems are usually easier to use and have more features.
Anyway, to generate a build directory with all the stuff required for compilation, run this from project&amp;rsquo;s directory&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>meson setup builddir
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The argument &lt;code>builddir&lt;/code> is the name of our build directory.
If you&amp;rsquo;ve set up your compiler and Ninja correctly, you should get some info about compiler executables and your environment, and &lt;code>builddir&lt;/code> directory should appear with some Meson and Ninja files.&lt;/p>
&lt;pre tabindex="0">&lt;code>PS&amp;gt; meson setup builddir
The Meson build system
Version: 1.3.1
Source dir: F:\Projects\C_C++\meson_c_cpp_project_template
Build dir: F:\Projects\C_C++\meson_c_cpp_project_template\builddir
Build type: native build
Project name: project_template
Project version: 0.1
C++ compiler for the host machine: ccache c++ (gcc 13.2.0 &amp;#34;c++ (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht Sanders) 13.2.0&amp;#34;)
C++ linker for the host machine: c++ ld.bfd 2.41
Host machine cpu family: x86_64
Host machine cpu: x86_64
Build targets in project: 1
Found ninja-1.11.1.git.kitware.jobserver-1 at C:\gcc\bin\ninja.EXE
&lt;/code>&lt;/pre>&lt;p>Now, we can tell Meson to compile the project:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>meson compile -C builddir
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>We could also use &lt;code>ninja&lt;/code> directly, but I&amp;rsquo;ll stick to using Meson whenever possible instead, for compatibility reasons.
That&amp;rsquo;s actually a core part of this template - we &lt;strong>want&lt;/strong> Meson to do stuff for us, we don&amp;rsquo;t want to care what happens under the hood.&lt;/p>
&lt;/blockquote>
&lt;p>We should get some output from Ninja.&lt;/p>
&lt;pre tabindex="0">&lt;code>PS&amp;gt; meson compile -C builddir
ninja: Entering directory `F:/Projects/C_C++/meson_c_cpp_project_template/builddir&amp;#39;
[2/2] Linking target project_template.exe
&lt;/code>&lt;/pre>&lt;p>And an executable&lt;/p>
&lt;pre tabindex="0">&lt;code>PS .&amp;gt; cd .\builddir\
PS .\builddir&amp;gt; .\project_template.exe
This is project project_template.
PS .\builddir&amp;gt; .\project_template.exe hello world
F:\Projects\C_C++\meson_c_cpp_project_template\builddir\project_template.exetakes no arguments.
&lt;/code>&lt;/pre>&lt;p>And also a test!&lt;/p>
&lt;pre tabindex="0">&lt;code>meson test
&lt;/code>&lt;/pre>&lt;p>Oh, if you haven&amp;rsquo;t noticed yet - the &lt;code>-C&lt;/code> argument changes the working directory of Meson, so it&amp;rsquo;s necessary only when you&amp;rsquo;re outside of it.
I assume that we &lt;code>cd&lt;/code>&amp;rsquo;d into it in previous step, so we don&amp;rsquo;t need it now.
I&amp;rsquo;ll also stop adding it to future example invocations, just remember that it exists and that Meson&amp;rsquo;s working directory must be the one that was generated via &lt;code>meson setup&lt;/code> for most commands.&lt;/p>
&lt;p>Let&amp;rsquo;s look at the output:&lt;/p>
&lt;pre tabindex="0">&lt;code>PS .\builddir&amp;gt;meson test
ninja: Entering directory `F:\Projects\C_C++\meson_c_cpp_project_template\builddir&amp;#39;
ninja: no work to do.
1/1 basic OK 0.01s
Ok: 1
Expected Fail: 0
Fail: 0
Unexpected Pass: 0
Skipped: 0
Timeout: 0
Full log written to F:\Projects\C_C++\meson_c_cpp_project_template\builddir\meson-logs\testlog.txt
&lt;/code>&lt;/pre>&lt;p>Yeah, that checks out, we have one &amp;ldquo;test&amp;rdquo; and it does nothing and returns 0, so it passes.
If you have encountered any issues until now, take a break and investigate.
Check if everything is where it&amp;rsquo;s supposed to be.
You can also run &lt;code>meson&lt;/code> commands with &lt;code>--help&lt;/code> flag to see what options you have available, just as an exercise.
Continue, when you&amp;rsquo;re ready.&lt;/p>
&lt;h2 id="structuring-our-project">Structuring our project&lt;/h2>
&lt;p>Now it&amp;rsquo;s time to think about the structure of our project.
We must be aware of the fact that there&amp;rsquo;s no one &amp;ldquo;best&amp;rdquo; project structure that would suit every kind of project.
However, due to the fact that I&amp;rsquo;d rather not work on a completely abstract project, we&amp;rsquo;ll have to make some assumptions about it&amp;rsquo;s structure, at least for now.&lt;/p>
&lt;p>Let&amp;rsquo;s gather what we already assumed about our project.
We assumed that it&amp;rsquo;s supposed to be testable.
Unit tests are the bare minimum that we want to support.
We also assumed that we&amp;rsquo;d like our code to be checked by external tools, but we can ignore that, because those tools should work no matter how we structure our project.
It&amp;rsquo;s just the matter of invoking them properly.
Same thing with Doxygen.
As for &lt;code>clangd&lt;/code>, Meson provides &lt;code>compile_commands.json&lt;/code>, therefore it will work as long as the structure is valid.&lt;/p>
&lt;p>Considering the usual good design practices, we&amp;rsquo;ll probably want to split our codebase into modules according to their responsibility.
No, not &lt;a href="https://en.cppreference.com/w/cpp/language/modules">&lt;em>those&lt;/em>&lt;/a> modules, let&amp;rsquo;s ignore the existence of C++20 for now.
We can store each module in a separate directory, with it&amp;rsquo;s own &lt;code>meson.build&lt;/code> file that would define how it&amp;rsquo;s built.
Modules can be built as static libraries and linked to executables.
That way, it&amp;rsquo;s trivial to test them - we can just link the same binary that&amp;rsquo;s used with our program executable to the test executable, and validate it&amp;rsquo;s behavior.&lt;/p>
&lt;blockquote>
&lt;p>This is how it&amp;rsquo;s done in some projects that I&amp;rsquo;ve been working on in my current job, and if it&amp;rsquo;s good enough choice for space-grade projects, it&amp;rsquo;s sure as hell good enough choice for me.
But really, I&amp;rsquo;ve seen this approach in action and it should work well.&lt;/p>
&lt;/blockquote>
&lt;p>Let&amp;rsquo;s also assume that our project can contain more than one executable, because it should be simple to setup for that.
We&amp;rsquo;re gonna put them in &lt;code>apps&lt;/code> directory.
Modules will go to &lt;code>lib&lt;/code>, and tests into &lt;code>tests&lt;/code>.&lt;/p>
&lt;p>Let&amp;rsquo;s create some dummy libs, tests for them, and an application to tie it together.
Also; let&amp;rsquo;s add &lt;code>meson.build&lt;/code> to each directory, empty - for now.
This is how it might look like:&lt;/p>
&lt;pre tabindex="0">&lt;code>meson_c_cpp_project_template
â meson.build
â
ââââapps
â ââââhello_world
â hello_world.cpp
â meson.build
â
ââââlib
â ââââcalc
â â calc.cpp
â â calc.hpp
â â meson.build
â â
â ââââgreeter
â greeter.cpp
â greeter.hpp
â meson.build
â
ââââtests
ââââcalc
â calc_test.cpp
â meson.build
â
ââââgreeter
greeter_test.cpp
meson.build
&lt;/code>&lt;/pre>&lt;h3 id="adding-libraries">Adding libraries&lt;/h3>
&lt;p>Let&amp;rsquo;s ignore the fact that we don&amp;rsquo;t have a test harness yet, and focus on making the libraries build.
But first, we have to put some code into them:&lt;/p>
&lt;p>calc.hpp:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pragma once
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">celcius_to_fahrenheit&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> celcius);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">fahrenheit_to_celcius&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> fahrenheit);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>calc.cpp:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;calc.hpp&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">celcius_to_fahrenheit&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> celcius) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (celcius &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">9.0&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">5.0&lt;/span>)) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">32.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">fahrenheit_to_celcius&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> fahrenheit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (fahrenheit &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">32.0&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#ae81ff">5.0&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">9.0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>greeter.hpp:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pragma once
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>string greet(std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">const&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> name);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>greeter.cpp:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;greeter.hpp&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>string greet(std&lt;span style="color:#f92672">::&lt;/span>string &lt;span style="color:#66d9ef">const&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string(&lt;span style="color:#e6db74">&amp;#34;Hello &amp;#34;&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now, let&amp;rsquo;s fill &lt;code>meson.build&lt;/code> files.
In order to build a library, we have to use &lt;code>library()&lt;/code> function. Duh.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>calc &lt;span style="color:#f92672">=&lt;/span> library(&lt;span style="color:#e6db74">&amp;#39;calc&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;calc.cpp&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The first argument is name of the library, followed by 0 or more sources in next arguments.
There are some options that we can set here using keyword arguments, but we&amp;rsquo;re gonna ignore them for now because we don&amp;rsquo;t need any.
We also save the result of this function to &lt;code>calc&lt;/code> variable, which we&amp;rsquo;re gonna use later.
We need to do the same thing for the other module, and the next step is modifying our top-level &lt;code>meson.build&lt;/code> to recognize this dependency.
Let&amp;rsquo;s remove the &lt;code>executable()&lt;/code> and &lt;code>test()&lt;/code> calls generated by Meson, and call &lt;code>subdir&lt;/code> instead, to include &lt;code>lib&lt;/code> directory.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>project(&lt;span style="color:#e6db74">&amp;#39;project_template&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version : &lt;span style="color:#e6db74">&amp;#39;0.1&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> default_options : [&lt;span style="color:#e6db74">&amp;#39;warning_level=3&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;cpp_std=c++14&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;lib&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, we&amp;rsquo;re gonna create &lt;code>meson.build&lt;/code> in &lt;code>lib&lt;/code>, that will include all the modules we currently have.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;calc&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;greeter&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And now, we should be able to build them.
I recommend removing &lt;code>builddir&lt;/code> directory after every big change, although I&amp;rsquo;m pretty sure that there is a way to do it in more elegant fashion (re-&lt;code>setup&lt;/code>?), and re-generating the build files.
Oh, yeah, it&amp;rsquo;s &lt;code>meson setup --reconfigure builddir&lt;/code>.
There you go.
And I got instantly reminded why I&amp;rsquo;m not using it - it doesn&amp;rsquo;t really reconfigure &lt;em>everything&lt;/em>, so it&amp;rsquo;s better to stick to the ol&amp;rsquo; reliable &lt;code>rm builddir&lt;/code> technique, at least until our project&amp;rsquo;s structure stabilizes a bit.&lt;/p>
&lt;pre tabindex="0">&lt;code>PS&amp;gt; meson setup builddir
The Meson build system
Version: 1.3.1
Source dir: F:\Projects\C_C++\meson_c_cpp_project_template
Build dir: F:\Projects\C_C++\meson_c_cpp_project_template\builddir
Build type: native build
Project name: project_template
Project version: 0.1
C++ compiler for the host machine: ccache c++ (gcc 13.2.0 &amp;#34;c++ (MinGW-W64 x86_64-ucrt-posix-seh, built by Brecht
Sanders) 13.2.0&amp;#34;)
C++ linker for the host machine: c++ ld.bfd 2.41
Host machine cpu family: x86_64
Host machine cpu: x86_64
Build targets in project: 2
Found ninja-1.11.1.git.kitware.jobserver-1 at C:\gcc\bin\ninja.EXE
PS&amp;gt; meson compile -C builddir
INFO: autodetecting backend as ninja
INFO: calculating backend command to run: C:\gcc\bin\ninja.EXE -C F:/Projects/C_C++/meson_c_cpp_project_template/
builddir
ninja: Entering directory `F:/Projects/C_C++/meson_c_cpp_project_template/builddir&amp;#39;
[4/4] Linking target lib/greeter/libgreeter.dll
&lt;/code>&lt;/pre>&lt;p>And it seems that it works.
It detected 2 build targets in project, exactly what we wanted to see.
Let&amp;rsquo;s look at &lt;code>builddir&lt;/code> to confirm it.&lt;/p>
&lt;pre tabindex="0">&lt;code>meson_c_cpp_project_template\builddir\lib
ââââcalc
â â libcalc.dll
â â libcalc.dll.a
â â
â ââââlibcalc.dll.p
â calc.cpp.obj
â
ââââgreeter
â libgreeter.dll
â libgreeter.dll.a
â
ââââlibgreeter.dll.p
greeter.cpp.obj
&lt;/code>&lt;/pre>&lt;p>Okay, but we got DLLs (or &lt;code>.so&lt;/code>&amp;rsquo;s, if you&amp;rsquo;re running Linux).
We don&amp;rsquo;t want dynamic libs, we want static libs.
Fortunately, there&amp;rsquo;s an easy fix, straight from the docs - &lt;code>library()&lt;/code> respects the &lt;code>default_library&lt;/code> project option, so we just have to change it in our project&amp;rsquo;s settings before building the libs.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>project(&lt;span style="color:#e6db74">&amp;#39;project_template&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version : &lt;span style="color:#e6db74">&amp;#39;0.1&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> default_options : {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;warning_level&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;3&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;cpp_std&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;c++14&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;c_std&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;c11&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;default_library&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;static&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I took an opportunity to refactor that ugly array list into a proper dict, and set the default C standard to C11.
You can find the list of available default options &lt;a href="https://mesonbuild.com/Builtin-options.html#base-options">here&lt;/a>, if you&amp;rsquo;re interested.
Let&amp;rsquo;s rebuild the project (again, &lt;code>--reconfigure&lt;/code> may not detect this change, so &lt;code>rm builddir&lt;/code>), and as we can see - we&amp;rsquo;ve got static libs now!&lt;/p>
&lt;pre tabindex="0">&lt;code>meson_c_cpp_project_template\builddir\lib
ââââcalc
â â libcalc.a
â â
â ââââlibcalc.a.p
â calc.cpp.obj
â
ââââgreeter
â libgreeter.a
â
ââââlibgreeter.a.p
greeter.cpp.obj
&lt;/code>&lt;/pre>&lt;h3 id="adding-an-executable">Adding an executable&lt;/h3>
&lt;p>Next, let&amp;rsquo;s use those libs with our executable.
Example &lt;code>hello_world.cpp&lt;/code> may look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;calc.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;greeter.hpp&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> greet(&lt;span style="color:#e6db74">&amp;#34;random developer&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;12.5*F == &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> fahrenheit_to_celcius(&lt;span style="color:#ae81ff">12.5&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*C&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;12.5*C == &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> celcius_to_fahrenheit(&lt;span style="color:#ae81ff">12.5&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*F&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Of course, the LSP will not be able to detect those headers properly yet, so ignore all the errors.
Let the toolchain speak the truth.
This is the content of &lt;code>hello_world&lt;/code>&amp;rsquo;s directory &lt;code>meson.build&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>hello_world &lt;span style="color:#f92672">=&lt;/span> executable(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;hello_world&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;hello_world.cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with: [calc, greeter]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice that we&amp;rsquo;ve used previously defined &lt;code>calc&lt;/code> and &lt;code>greeter&lt;/code> variables.
In order to do that, &lt;code>lib&lt;/code> subdirectory must be evaluated before &lt;code>apps&lt;/code>, and that&amp;rsquo;s why &lt;code>subdir('apps')&lt;/code> call must be put below &lt;code>subdir('lib')&lt;/code> in our main &lt;code>meson.build&lt;/code> file.
&lt;code>subdir&lt;/code> basically evaluates the &lt;code>meson.build&lt;/code> from the directory provided via the argument, and retains the environment after that.
Pretty useful, but we have to be careful not to misuse that feature, otherwise our Meson scripts may become very fragile and complicated to maintain.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;lib&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;apps&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We also have to create &lt;code>meson.build&lt;/code> for &lt;code>apps&lt;/code> directory.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>subdir(&lt;span style="color:#e6db74">&amp;#39;hello_world&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>And yes, we probably could just &lt;code>subdir('apps/hello_world')&lt;/code>, but I wanna keep everything as local as possible.
You may add &lt;code>meson.build&lt;/code> to every directory of the project now, because we&amp;rsquo;re gonna need them.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>meson setup builddir&lt;/code> tells me that there are 3 targets now.
That&amp;rsquo;s what we want.
But after running &lt;code>meson compile -C builddir&lt;/code>, it seems that we have a problem.&lt;/p>
&lt;pre tabindex="0">&lt;code>../apps/hello_world/hello_world.cpp:1:10: fatal error: calc.hpp: No such file or directory
1 | #include &amp;lt;calc.hpp&amp;gt;
| ^~~~~~~~~~
compilation terminated.
&lt;/code>&lt;/pre>&lt;p>Yeah, that checks out.
We&amp;rsquo;ve linked the libs, but we never told &lt;code>executable()&lt;/code> where are their include files.
To do that, we need to use &lt;code>include_directories&lt;/code> argument of &lt;code>executable()&lt;/code>, which expects a list of objects created using &lt;code>include_directories()&lt;/code> function.
And &lt;code>include_directories()&lt;/code> accepts string with relative paths, so we can just add them to the &lt;code>meson.build&lt;/code> of our libraries and use them just like the objects returned from &lt;code>library()&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>calc_lib &lt;span style="color:#f92672">=&lt;/span> library(&lt;span style="color:#e6db74">&amp;#39;calc&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;calc.cpp&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>calc_includes &lt;span style="color:#f92672">=&lt;/span> include_directories(&lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I&amp;rsquo;ve also added the suffix to lib.
We need to do the same for &lt;code>greeter&lt;/code>, and fix our &lt;code>hello_world&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-meson" data-lang="meson">&lt;span style="display:flex;">&lt;span>hello_world &lt;span style="color:#f92672">=&lt;/span> executable(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;hello_world&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;hello_world.cpp&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link_with: [calc_lib, greeter_lib],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> include_directories: [calc_includes, greeter_includes],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And voila, we should have a green build now!
Let&amp;rsquo;s see if the executable actually works.&lt;/p>
&lt;pre tabindex="0">&lt;code>PS&amp;gt; .\builddir\apps\hello_world\hello_world.exe
Hello random developer
12.5*F == -10.8333*C
12.5*C == 54.5*F
&lt;/code>&lt;/pre>&lt;p>Yeah, the output checks out.
And that is where I&amp;rsquo;d like to finish this part, because it&amp;rsquo;s already long enough, but there&amp;rsquo;s just one tiny thing that annoys me&amp;hellip;&lt;/p>
&lt;h2 id="feeding-the-lsp">Feeding the LSP&lt;/h2>
&lt;p>I assume that you&amp;rsquo;re using an editor/IDE with LSP support, and will be using &lt;code>clangd&lt;/code>.
If that&amp;rsquo;s not the case, i strongly recommend getting one.
I personally use &lt;a href="https://neovim.io/">neovim&lt;/a>, but I cannot really recommend it to everyone, so &lt;a href="https://code.visualstudio.com/">Visual Studio Code&lt;/a> with &lt;a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd plugin&lt;/a> should be more than enough.
You may want to look at my older guide to see how to setup that combination.
&lt;strong>You can find it &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#bonus-clangd-setup">here&lt;/a>.&lt;/strong>
Meson generates &lt;code>compile_commands.json&lt;/code> by default, automatically on every build (i think).
However, &lt;code>clangd&lt;/code> will not be aware of that, because this file will be stored in &lt;code>builddir&lt;/code> instead of our project&amp;rsquo;s root directory, so we have two options:&lt;/p>
&lt;ol>
&lt;li>Tell &lt;code>clangd&lt;/code> that &lt;code>compile_commands.json&lt;/code> is in &lt;code>builddir/&lt;/code>&lt;/li>
&lt;li>Copy/link &lt;code>compile_commands.json&lt;/code> into root directory of our project&lt;/li>
&lt;/ol>
&lt;p>Fortunately, we can go with the first solution, because &lt;code>clangd&lt;/code> supports configuration, and has an option for telling it where the compilation database is.
Let&amp;rsquo;s create &lt;code>.clangd&lt;/code> file in the root of our project, and put it there:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">CompileFlags&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">CompilationDatabase&lt;/span>: &lt;span style="color:#ae81ff">builddir/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can also add some &lt;a href="https://clangd.llvm.org/config">additional config&lt;/a> for the LSP.&lt;/p>
&lt;p>aaaand&amp;hellip; It looks like it&amp;rsquo;s working for me, so that&amp;rsquo;s it, we&amp;rsquo;re done here.
I&amp;rsquo;ve made a tag and release on &lt;a href="https://github.com/SteelPh0enix/meson_c_cpp_project_template/tree/part-1">this project&amp;rsquo;s repository&lt;/a> if you want to go the easy route and just &lt;code>git clone&lt;/code> everything we&amp;rsquo;ve done here.
See you next time.&lt;/p></content></item><item><title>When should you choose C++ as your starting language?</title><link>https://steelph0enix.github.io/posts/choosing-first-language/</link><pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate><guid>https://steelph0enix.github.io/posts/choosing-first-language/</guid><description>&lt;p>When I&amp;rsquo;m lurking through the internet, I often see posts asking about &amp;ldquo;what language should I pick as a beginner???&amp;rdquo;. As someone who struggled a lot with this choice, and ultimately picked C++ (for reasons that made no real senseâbut, of course, I didn&amp;rsquo;t know that back then), I think I can say a few words about this specific choice and how it can affect the learning process of an individual.&lt;/p></description><content>&lt;p>When I&amp;rsquo;m lurking through the internet, I often see posts asking about &amp;ldquo;what language should I pick as a beginner???&amp;rdquo;. As someone who struggled a lot with this choice, and ultimately picked C++ (for reasons that made no real senseâbut, of course, I didn&amp;rsquo;t know that back then), I think I can say a few words about this specific choice and how it can affect the learning process of an individual.&lt;/p>
&lt;h2 id="its-a-trap">It&amp;rsquo;s a trap!&lt;/h2>
&lt;p>TL;DR of this post - it&amp;rsquo;s usually not a good idea to pick C++ as your starting language. After working with C++ for a long time, and tasting many different programming languages, I feel like C++ is a convoluted mess taped together using subpar-quality duct tape, somehow still holding on, maybe even going in a relatively good direction with recent changes, but certainly not good enough for a beginner to learn the programming principles on at its current state.&lt;/p>
&lt;h2 id="why-would-you-even-want-to-do-that">Why would you even want to do that?&lt;/h2>
&lt;p>Excellent question! In most cases, I hear these specific arguments, trying very hard to justify picking C++ as a starter:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>It&amp;rsquo;s very fast!&lt;/strong>âvery common misconception. &lt;strong>Languages are not inherently fast nor slow&lt;/strong>. Sure, some languages can be &lt;em>parsed&lt;/em> or &lt;em>interpreted&lt;/em>, faster than others, but it does not imply that a &lt;strong>program&lt;/strong> written in language A will &lt;em>always&lt;/em> be faster than a program written in language B, or vice versa. Surely, that can be a thing - we absolutely can write a program in C++ that will be faster than an equivalent program in Python or Java, but &lt;strong>it works both ways!&lt;/strong> A good practice is asking yourself &lt;em>&amp;ldquo;why?&amp;rdquo;&lt;/em> and &lt;em>&amp;ldquo;when?&amp;rdquo;.&lt;/em> Why a program written in language &lt;code>A&lt;/code> may be faster/slower than an equivalent program written in language &lt;code>B&lt;/code>? And at what scale does it become meaningful to performance? But that&amp;rsquo;s not something that a newbie should care about. Generally speaking, you should NOT care about &amp;ldquo;language performance&amp;rdquo; as a beginner, as it&amp;rsquo;s one of the last things you&amp;rsquo;ll have to worry about when learning programming. In the beginning, the real performance will lie mostly in data structures and algorithms used in your code, not the language choice.&lt;/li>
&lt;li>&lt;strong>Learning C++ teaches you low-level concepts, like pointers and manual memory management!&lt;/strong> It can, but there&amp;rsquo;s a biiiiiig &lt;strong>but&lt;/strong>. &lt;strong>You don&amp;rsquo;t have to know these low-level concepts to write software and learn programming.&lt;/strong> Every day thousands of programmers write perfectly fine and working code without even knowing what a pointer is, or how to manually manage the memory. It&amp;rsquo;s not something that you absolutely must know in order to write working code. It&amp;rsquo;s not something that may ever be useful for you. I certainly agree with people saying that knowing how pointers and manual memory management work can be useful in many situations, but for a beginnerâit&amp;rsquo;s certainly not a must-know, as even in C++ you usually don&amp;rsquo;t want to manually manage raw pointers and memory allocations.&lt;/li>
&lt;li>&lt;strong>Game programming is done in C++&lt;/strong>âusually paired with the &amp;ldquo;much performance&amp;rdquo; argumentâis also invalid, as there are plenty of very popular game engines that provide a much more newbie-friendly approach to game development. Check out &lt;a href="https://godotengine.org/">Godot&lt;/a> as one of the best examples, since it has both its own toolset that uses its own GDScript language, but also can be used with other languages and tools if you prefer that approach or you already know them and don&amp;rsquo;t want to learn new stuff. I know there are plenty of people doing gamedev in C++, and they do have a point in thatâbeing relatively close to the hardware it&amp;rsquo;s not the worst choice of a language, but I still strongly believe that it&amp;rsquo;s an overkill if you want to learn &lt;strong>&amp;ldquo;programming&amp;rdquo;&lt;/strong> and &lt;strong>&amp;ldquo;game development&amp;rdquo;&lt;/strong>, as it carries a heavy bag of &lt;strong>&amp;ldquo;having to learn C++&amp;rdquo;&lt;/strong> before learning the stuff you really wanna learn. Don&amp;rsquo;t forget that, if you&amp;rsquo;re thinking that it&amp;rsquo;ll be a breeze and something you&amp;rsquo;ll do &amp;ldquo;on the side&amp;rdquo;, &lt;em>you may lack some crucial knowledge&lt;/em>. Of course, if you wanna do it &amp;ldquo;raw&amp;rdquo; and really refuse to use existing game engines, you absolutely can do it in any language that has &lt;em>some&lt;/em> kind of multimedia API&amp;hellip; so, basically, the most available and popular languages for sane people (brainfuck btfo). If you don&amp;rsquo;t believe me, &lt;a href="https://store.steampowered.com/app/824600/HROT/">this game was written in Pascal, from scratch, in 2017. And it runs great!&lt;/a>&lt;/li>
&lt;li>&lt;strong>I know some C, so C++ is just an extension, so I&amp;rsquo;ll learn it.&lt;/strong> It is not, and thinking that way will force you onto a path from which it&amp;rsquo;s very hard to return, as I have witnessed multiple times with my own eyes. Beware of thinking about C++ as an addition to C, as it&amp;rsquo;s just as foolish as thinking about a dragon being an addition to his precious mountain of gold. &lt;a href="https://en.cppreference.com/w/cpp/language/initialization">You WILL get burned&lt;/a>. &lt;a href="https://en.cppreference.com/w/cpp/language/lifetime">You WILL witness horrors beyond your comprehension&lt;/a>. &lt;a href="https://en.cppreference.com/w/cpp/language/value_category">That last part is also true when talking about C++ in general&lt;/a>. Compare the following articles with their C counterparts (the link is at the bottom of the reference page) and rethink your life choices.&lt;/li>
&lt;/ul>
&lt;p>That list may become longer with time.&lt;/p>
&lt;h2 id="so-what-are-the-alternatives">So, what are the alternatives?&lt;/h2>
&lt;p>Another excellent question! Loving the audience today.&lt;/p>
&lt;p>Obviously, I will have to answer according to my own opinions and beliefs, however, I will also try to explain why I think like I think I think. I think that will make it easier to, at least, continue your research. Remember - tÌ´hÌ´eÌ¶ Ì·rÌ·eÌµsÌ·eÌ´aÌ¸rÌ¸cÌ´hÌ¸ Ì¸nÌ·eÌ·vÌ¸eÌ·rÌ· Ì·eÌµnÌµdÌ´sÌ¸.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Python:&lt;/strong> Some people will tell you that Python sucks. Some people will tell you that Python is not a good language for beginners. Some people are wrong and cannot comprehend the simplicity and beauty of whitespace-defined syntax. I, however, will tell you that I love Python because it rarely disappoints me. I need to write a simple tool that does some stuff automatically, and I want it to work everywhere? Python is my guy. Its long support, big community, package manager, and existing tools are making it very hard for me not to recommend this language as a starter. The syntax is sure &lt;em>very specific&lt;/em>, some might even say &lt;em>exotic&lt;/em>, but after working with it for a while it annoys me only &lt;em>sometimes&lt;/em> when I have to move a block of code to a different place and manually fix every indent. And it even has type hints and easy-to-use tools that&amp;rsquo;ll make sure you adhere to typing rules, which some people may find very useful. For a beginner though, you&amp;rsquo;ll most likely want to focus on the vast &lt;a href="https://pypi.org/">PyPI&lt;/a> repository to write some useful stuff for yourself. Its &lt;a href="https://docs.python.org/3/index.html">documentation&lt;/a> is also relatively decent and even has a tutorial to get you started, but if you&amp;rsquo;re completely new to the IT and/or programming world I&amp;rsquo;d recommend looking for a first-time tutorial more suited to your level of knowledge, as the &amp;ldquo;official&amp;rdquo; one is not very newbie-oriented.&lt;/li>
&lt;li>&lt;strong>JavaScript&lt;/strong> (or maybe even &lt;strong>TypeScript?&lt;/strong>): It&amp;rsquo;s a very simple gateway to the vast world of web applications, but not only, as you can plug JavaScript almost anywhere nowadays&amp;hellip; I&amp;rsquo;m personally not a fan of this language, but from what I&amp;rsquo;ve seen - people who start from JavaScript have a certain &amp;ldquo;freedom&amp;rdquo; of being able to use this language anywhere they want, which is nice if you don&amp;rsquo;t know what you exactly want to do yet, but usually comes with additional baggage of tools for creating user interfaces - HTML and CSS being the usual ones, but most likely also paired with some fancy frameworks and other funky stuff thatâaccording to many web developersâare needed to write functional pages, for which &lt;a href="https://htmx.org/">more elegant technologies from simpler times&lt;/a> may be more than enough). I&amp;rsquo;m getting out of topic though, I endorse JavaScript as a starter way more than I endorse C++, but be aware of many pitfalls this language comes with. &lt;em>Which can be said about basically any language, but the Big Dev won&amp;rsquo;t tell you about that!&lt;/em>&lt;/li>
&lt;li>&lt;strong>Kotlin:&lt;/strong> If you want to learn Java for whatever god-forsaken reason you may have, don&amp;rsquo;t learn Javaâlearn Kotlin instead! If you wanna make Android apps and you&amp;rsquo;d rather use official tools than some webdev mumbo-jumbo, Kotlin is your guy! Its Java legacy makes it a reasonably good starting language, as you have both a nice, modern language with nice, modern syntax and useful features that are simply a joy to work with, and a vast repository of libraries, some written long before Kotlin even existed. I haven&amp;rsquo;t worked much with this language, but I enjoyed almost every moment of it.&lt;/li>
&lt;li>&lt;strong>C:&lt;/strong> Yeah, let&amp;rsquo;s put it on the list, why not. &lt;strong>You wanna have a very close relationship with your hardware? Here&amp;rsquo;s your language. Don&amp;rsquo;t tell me I didn&amp;rsquo;t warn you though.&lt;/strong>
&lt;img src="https://steelph0enix.github.io/img/this_machine_does_not_know_the_difference.png" alt="don&amp;#39;t say i didn&amp;#39;t warn you" class="center" />
In all fairness, C is certainly lackingâreal generics, for example, but that doesn&amp;rsquo;t stop people from using it even right now. As a language to get the hang of programming and &amp;ldquo;how does stuff work under the hood&amp;rdquo; it&amp;rsquo;s a great choice, as a language to write working applications without having to create a whole universe beforehand&amp;hellip; not so much, unless you work on something that does not require an entire universe to run, but I will get to it soon. I promise.&lt;/li>
&lt;/ul>
&lt;p>This list is by no means comprehensive. There are a lot of languages that are deemed &amp;ldquo;reasonable for beginners&amp;rdquo; that are not on this list, just because I either never worked with them, or worked so long ago that I cannot assume that my knowledge is still applicable to its current state (e.g. C#, which I&amp;rsquo;d like to say something about, but I really can&amp;rsquo;t).&lt;/p>
&lt;p>Notice that my focus here is to recommend a language that will be relatively easy to learn and easy to use, with a big community and lots of resources to learn fromâC++ is lacking in many of these aspects, which makes learning modern C++ the &amp;ldquo;correct&amp;rdquo; way surprisingly hard. And, to be fair, it makes doing &lt;em>anything&lt;/em> in C++ unreasonably convoluted and painful. Ever tried to set up a C++ project from scratch with automatic unit and integration tests? I did. And failed. Not because it&amp;rsquo;s impossible, but because I simply rather choose a language that supports that stuff out-of-the-box (unit testing, at least). And I&amp;rsquo;ve seen projects that do have this stuff in C++, and I&amp;hellip; uhh&amp;hellip; I&amp;rsquo;d rather avoid having to jump through the hoops of CMake and similar tools in order to have stuff that&amp;rsquo;s relatively easy to do in other languages &lt;em>usually without having to learn how to use 3rd party tools&lt;/em>. And there&amp;rsquo;s C, as a direct C++ alternative, and I&amp;rsquo;ll explain why it&amp;rsquo;s hereâbecause it&amp;rsquo;s certainly not for the same reason as other languages on this list.&lt;/p>
&lt;h2 id="when-it-actually-makes-sense-to-go-c-head-first">When it actually makes sense to go C++ head-first&lt;/h2>
&lt;p>As with any rules, there are exceptions, and this includes my &amp;ldquo;No C++ for beginners allowed&amp;rdquo; rule.&lt;/p>
&lt;p>The most obvious exception for me is targeting embedded programming as &lt;em>the thing you want to do&lt;/em>. And it&amp;rsquo;s also the reason why C is on my list - because C is &lt;em>much&lt;/em> simpler than C++, it might be a better idea to start with that instead. But if you wanna use Arduino, like most beginners nowadays, sticking only to C makes little sense as there are powerful and relatively easy-to-use features of C++ that you already have access to (and might have to use, depending on the libraries you work with). Sure, you may not have the standard library and its fancy features &lt;em>(and I&amp;rsquo;d argue that it&amp;rsquo;s a good thing)&lt;/em>, but you still have the power of templates, lambda expressions, constexpr, and many more cool features. So yeah, if you wanna tinker with hardware then learning C++ &lt;em>might&lt;/em> be unavoidable for you.&lt;/p>
&lt;p>But only &lt;em>might&lt;/em>âif you ignore the existence of Arduino frameworkânot the hardware, the hardware is its own thing and it&amp;rsquo;s just a &amp;ldquo;brand&amp;rdquo; name - you may just stick to pure C and write the code from scratch directly for the microcontroller you have, or using vendor-provided tools (like STM32CubeIDE for ST microcontrollers). However, this is substantially harder as it usually requires you to actually read the documentation of hardware you&amp;rsquo;re working on. It&amp;rsquo;s really not something for faint-hearted developers that would rather stick to copying and pasting random pieces of code from the internet or ChatGPT, with the hope that it&amp;rsquo;ll solve all their issues.&lt;/p>
&lt;p>Another obvious scenario is &amp;ldquo;you have to learn it because of school/university/work/side-project I&amp;rsquo;m doing with some C++ developers&amp;rdquo;. Or you may just be very, very, very fiercely and weirdly focused on learning C++. For that, I have no cure. I just have a tip: &lt;em>try to stick to modern sources and don&amp;rsquo;t get sucked by outdated, pre-C++11 tutorials and books that have questionable reputation&lt;/em>. There are many. &lt;a href="https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list/">There are curated lists of sources from which you can start your journey&lt;/a>.&lt;/p>
&lt;p>And I can&amp;rsquo;t really think about any other scenarios where C++ would &lt;em>really&lt;/em> make sense. Some time ago I&amp;rsquo;d say that OS-dev is a good niche for that, but you can do OS-dev in C as well, and there&amp;rsquo;s Rust for the cool kids that sit on the back of the busâmuch saner choice than C++ if you ask me. Borrow checker may go hard, but &lt;em>it&amp;rsquo;s there and will never leave you&lt;/em>. Do you want the same commitment from C or C++? Configure it yourself. And it won&amp;rsquo;t be half as good as what Rust does for your code. Graphics programming and game development? Yea, sure, maybe. Maybe if you are new in this world, still with hopes for a better tomorrow, still young and innocent, it will sound like a good choice - and you may even walk through this path relatively unscathed. But then again, you may not. I&amp;rsquo;d still look at alternatives first, &lt;em>just because lots of people do it in C++, doesn&amp;rsquo;t mean that you have to do it in C++ too&lt;/em>.&lt;/p>
&lt;p>I may sound like a big C++ hater, but to be honest, it earned it. I&amp;rsquo;ve spent years with that language, and half of this time I&amp;rsquo;ve spent fighting with it. Do I regret it? I regret not jumping this ship earlier, but I&amp;rsquo;d say that lots of things I&amp;rsquo;ve learned via C++ I&amp;rsquo;ve found useful at some point. Could I learn those things while focusing on different languages? Some of them, yes, but not all of them. Would I go a different path if I could start my journey again? Fuck yes, I&amp;rsquo;d jump straight to Python or webdev, but considering my areas of interests and expertise I&amp;rsquo;d end up with C++ at some point anyway.&lt;/p>
&lt;p>I&amp;rsquo;m also not saying that C++ should &lt;em>never&lt;/em> be learned or used. It&amp;rsquo;s got its things going, and with a certain amount of experience in general programming and with setting up software projects, it&amp;rsquo;s possible to work with it. But you need that experience and knowledge first, and head-slamming into a C++ wall may not help you get that knowledge in comparison with other available methods.&lt;/p></content></item><item><title>VSCode CubeMX Project Setup</title><link>https://steelph0enix.github.io/posts/vscode-cubemx-setup/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>https://steelph0enix.github.io/posts/vscode-cubemx-setup/</guid><description>&lt;p>Up until now, i&amp;rsquo;ve used STM32CubeIDE with STM32CubeMX as my primary development tools for STM32 microcontrollers. CubeIDE has lots of useful features available out-of-the-box. However, it also suffers from pretty feelable bloat, caused by the fact that it&amp;rsquo;s heavily modified Eclipse IDE with lots of plugins that pile up pretty quickly. It also lacks some features that i&amp;rsquo;m used to having in more&amp;hellip; &amp;ldquo;civilized&amp;rdquo; IDE&amp;rsquo;s (dark theme which is not hurting the eyes with contrast by default? better Git integration? and probably lots of other, smaller thingies). So, i&amp;rsquo;ve decided to try something new and the first obvious choice was Visual Studio Code.&lt;/p></description><content>&lt;p>Up until now, i&amp;rsquo;ve used STM32CubeIDE with STM32CubeMX as my primary development tools for STM32 microcontrollers. CubeIDE has lots of useful features available out-of-the-box. However, it also suffers from pretty feelable bloat, caused by the fact that it&amp;rsquo;s heavily modified Eclipse IDE with lots of plugins that pile up pretty quickly. It also lacks some features that i&amp;rsquo;m used to having in more&amp;hellip; &amp;ldquo;civilized&amp;rdquo; IDE&amp;rsquo;s (dark theme which is not hurting the eyes with contrast by default? better Git integration? and probably lots of other, smaller thingies). So, i&amp;rsquo;ve decided to try something new and the first obvious choice was Visual Studio Code.&lt;/p>
&lt;blockquote>
&lt;p>The second choice would be CLion, which has pretty decent CubeMX project support out-of-the-box, but it is sometimes a little bit buggy with debugging the projects&amp;hellip; or at least it was few months ago, when i tried it. Maybe it got fixed.&lt;/p>
&lt;/blockquote>
&lt;p>So, after few hours of tinkering and lurking around for guides and plugins, i&amp;rsquo;ve found my setup. Most of the config i&amp;rsquo;ve taken from two great videos by &lt;a href="https://www.youtube.com/channel/UCuigr_BEzX1g3Qvwq5QjPXg">Embedded Geek&lt;/a> (first one is &lt;a href="https://www.youtube.com/watch?v=PxQw5_7yI8Q">here&lt;/a>, second one - &lt;a href="https://www.youtube.com/watch?v=xaC5oWwzOt0">here&lt;/a>), but i&amp;rsquo;ve changed some things since i&amp;rsquo;m not using the exact same VSCode config as he does (which, actually, makes things easier and less painful to configure for me). I also made sure that it should work on both Windows and Linux (and &lt;em>probably&lt;/em> MacOS).&lt;/p>
&lt;blockquote>
&lt;p>If you are very lazy, you can use &lt;a href="https://marketplace.visualstudio.com/items?itemName=bmd.stm32-for-vscode">&lt;code>stm32-for-vscode&lt;/code>&lt;/a> plugin instead of this guide. It should do most of the work described there automatically. However, it uses default IntelliSense engine, and as i prefer clangd and knowing how to configure the project from scratch (so when something goes wrong, i know how to fix it), i still created this guide. &lt;em>I&amp;rsquo;ve used it in the past, but after trying it again and comparing with setup made using this guide i found out it doesn&amp;rsquo;t offer better experience in the long run&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>Anyway, let&amp;rsquo;s get to it.&lt;/p>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;p>From hardware side, you need to have an STM32 board, and a debugger that&amp;rsquo;s compatible with it. For this guide, i&amp;rsquo;m using Nucleo-G474RE, with STM32G474RET6 microcontroller, and STLink v3 onboard. The exact choice of MCU and debugger doesn&amp;rsquo;t matter, as this setup will work with any STM32 MCU and every debugger supported by OpenOCD. Also, you&amp;rsquo;ll need an USB cable to connect the board to your PC.
&lt;strong>If you&amp;rsquo;re using ST-Link, update it&amp;rsquo;s firmware before proceeding. You can do it with &lt;a href="https://www.st.com/en/development-tools/stsw-link007.html">this official tool&lt;/a>&lt;/strong>. Free ST account is required to download it.&lt;/p>
&lt;p>From software side, these tools are required:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.st.com/en/development-tools/stm32cubemx.html">&lt;strong>STM32CubeMX&lt;/strong>&lt;/a> - STM32 MCU helper and code generator, simplifies the project generation and MCU initialization to maximum - downloadable for free from official ST site &lt;a href="https://www.st.com/en/development-tools/stm32cubemx.html">here&lt;/a>. Requires free ST account to download. &lt;em>PSA for HAL-haters: you don&amp;rsquo;t have to use HAL even if you generate the code using CubeMX - read about LL libraries, you can use them too, and they are as close to the metal as it&amp;rsquo;s sanely possible. I&amp;rsquo;ll put a quick info about it at the end of this guide, as a bonus.&lt;/em>&lt;/li>
&lt;li>&lt;a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">&lt;strong>ARM-GCC toolchain&lt;/strong>&lt;/a> (&lt;code>arm-none-eabi-gcc&lt;/code> to be specific, along with all the other GCC tools, and GDB). Linux users should have latest version in the repositories - make sure you also install &lt;code>arm-none-eabi-newlib&lt;/code> and &lt;code>arm-none-eabi-binutils&lt;/code> if these are separate packages. Windows users can either use their preferred package manager, or download the latest toolchain manually from &lt;a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">official ARM site&lt;/a> - MacOS and Linux versions are available there too, in case you don&amp;rsquo;t have one in repositories. &lt;strong>Just make sure it&amp;rsquo;s in your OS PATH variable before proceeding - open terminal and try running &lt;code>arm-none-eabi-gcc --version&lt;/code>. If it fails, add the toolchain&amp;rsquo;s &lt;code>bin&lt;/code> directory to PATH.&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://openocd.org/pages/getting-openocd.html">&lt;strong>OpenOCD&lt;/strong>&lt;/a> - we&amp;rsquo;ll use it to debug and flash the firmware on our microcontroller. Get it from your package manager, or via one of the unofficial distributions listed &lt;a href="https://openocd.org/pages/getting-openocd.html">here&lt;/a>. Or you can also build it from source, which is fairly easy. &lt;strong>Make sure it&amp;rsquo;s in PATH too - check if &lt;code>openocd --version&lt;/code> prints the info, if not - add the directory with it&amp;rsquo;s executable to PATH.&lt;/strong>&lt;/li>
&lt;li>&lt;a href="https://code.visualstudio.com/">&lt;strong>Visual Studio Code&lt;/strong>&lt;/a> - obviously. If you are new to this editor, i strongly suggest to check out &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/">my previous guide&lt;/a> about configuring it for C/C++ projects with CMake. We won&amp;rsquo;t use CMake here (although it is possible to do that with a little bit of help from &lt;a href="https://github.com/ObKo/stm32-cmake">&lt;code>stm32-cmake&lt;/code>&lt;/a> repository), but i will use &lt;code>clangd&lt;/code>, as i prefer this language server over the default one, and it&amp;rsquo;s easier to set-up. So, if you want to stay with default language server, keep in mind that you will have to configure include paths manually, which is painful and i won&amp;rsquo;t describe it here. &lt;em>If you have no idea what i&amp;rsquo;m writing about here - just follow this guide and install all the plugins listed below&lt;/em>. I strongly recommend to use these plugins for VSCode:
&lt;ul>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">&lt;strong>C/C++&lt;/strong>&lt;/a> - for general C and C++ language support - &lt;strong>required&lt;/strong>;&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">&lt;strong>Cortex-Debug&lt;/strong>&lt;/a> - for ARM Cortex-M debugging - &lt;strong>required&lt;/strong>;&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">&lt;strong>clangd&lt;/strong>&lt;/a> - alternative language server that usually works better than default one, and has easier and more robust config. Also features configurable code auto-formatting. If you don&amp;rsquo;t know what language server does, or you haven&amp;rsquo;t played with default one yet - install and use &lt;code>clangd&lt;/code>, you can find basic setup instructions &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#bonus-clangd-setup">here&lt;/a>, and i&amp;rsquo;ll guide you through configuration for this project. If you know what you&amp;rsquo;re doing - have fun.&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=dan-c-underwood.arm">&lt;strong>ARM&lt;/strong>&lt;/a> - for ARM assembly language support. Useful when lurking around *.s files - optional;&lt;/li>
&lt;li>&lt;a href="https://marketplace.visualstudio.com/items?itemName=ZixuanWang.linkerscript">&lt;strong>LinkerScript&lt;/strong>&lt;/a> - for linker script language support. Useful when lurking around *.ld files - optional;&lt;/li>
&lt;li>And also plugins from my list of recommended C/C++ plugins, which you can find &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#vscode-essential-plugins">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://www.st.com/en/development-tools/stsw-link009.html">&lt;strong>ST-Link (or your preferred debugger) drivers&lt;/strong>&lt;/a> - if you already have &lt;a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE&lt;/a> or &lt;a href="https://www.st.com/en/development-tools/stm32cubeprog.html">STM32CubeProgrammer&lt;/a> installed on your system, you should already have them. If that&amp;rsquo;s not the case, then either install STM32CubeProgrammer to get all the drivers that you&amp;rsquo;d need for most STM32-compatible debuggers, or download and install the drivers for your specific debugger and OS manually. &lt;strong>Just make sure that your debugger is detected correctly by your operating system before proceeding&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>And that should be just about it. If you have everything set-up, can get to work on our project.&lt;/p>
&lt;h2 id="creating-a-project">Creating a project&lt;/h2>
&lt;p>Open up STM32CubeMX and make a new project. I&amp;rsquo;ll assume that you already have basic knowledge of STM32CubeMX usage, so you can create a project for your board. After that, set up your peripherals (i&amp;rsquo;ll just use onboard LED which is set up by default to test stuff out), make sure the debug is enabled (System Core -&amp;gt; SYS -&amp;gt; Debug), clocks are configured correctly (Clock Configuration tab on the top of the window), and go to Project Manager tab. Fill up the project name and location, and set &lt;strong>Toolchain/IDE&lt;/strong> to &lt;strong>Makefile&lt;/strong>. Save the project after that.&lt;/p>
&lt;p>&lt;img alt="cubemx-project-config-1" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/cubemx-config-1.png">&lt;/p>
&lt;p>Next, i recommend going to &lt;strong>Code Generator&lt;/strong> tab on the left and selecting all the checkboxes in &lt;strong>Generated files&lt;/strong> section. I do it as force of habit, to have a bit better organized project.&lt;/p>
&lt;p>&lt;img alt="cubemx-project-config-2" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/cubemx-config-2.png">&lt;/p>
&lt;p>When you&amp;rsquo;re done with CubeMX config, &lt;strong>Generate the code&lt;/strong> and open the directory with the project in Visual Studio Code.&lt;/p>
&lt;h2 id="setting-up-the-project-in-vscode">Setting up the project in VSCode&lt;/h2>
&lt;h3 id="building-the-project">Building the project&lt;/h3>
&lt;p>Now, time for the fun part. First, we&amp;rsquo;ll make sure we can build the project. Open integrated terminal (&lt;code>Ctrl+` &lt;/code> to open existing one, or &lt;code>Ctrl+Shift+` &lt;/code> to create a new one) and run &lt;code>make&lt;/code>. You should see some output - the commands ran by Make, and size of output binary - and a new directory called &lt;code>build&lt;/code> should appear. The project directory should look like this now:&lt;/p>
&lt;p>&lt;img alt="post-build-file-tree" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/post-build-files-tree.png">&lt;/p>
&lt;blockquote>
&lt;p>If the build failed, read the error message, check if you have all required prerequisites, and look around the internet for support - most of basic issues have been solved by someone already, and solutions are out there.&lt;/p>
&lt;/blockquote>
&lt;p>The &lt;code>build&lt;/code> directory should contain a lot of object (&lt;code>*.o&lt;/code>) , listing (&lt;code>*.lst&lt;/code>), and &lt;code>*.d&lt;/code> files, along with few binaries with the same name as your project, and also a &lt;code>*.map&lt;/code> file, which contains the memory map of whole program.&lt;/p>
&lt;p>&lt;img alt="post-build-file-out" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/post-build-files-out.png">&lt;/p>
&lt;p>The only file here that&amp;rsquo;s currently interesting for us is the &lt;code>*.elf&lt;/code> file - this is the actual compiled binary we&amp;rsquo;ll flash to MCU using OpenOCD. &lt;code>*.bin&lt;/code> and &lt;code>*.hex&lt;/code> files are compiled binary files too, created out of the &lt;code>*.elf&lt;/code> file, but they are usually used in different scenarios (for example, &lt;code>*.bin&lt;/code> file can easily be used by custom bootloaders, as it&amp;rsquo;s basically raw compiled code, stripped out of unnecessary stuff).&lt;/p>
&lt;h3 id="configuring-the-language-server-clangd">Configuring the language server (clangd)&lt;/h3>
&lt;p>If you&amp;rsquo;re able to build project successfully, then it&amp;rsquo;s time to set up our language server. Clangd requires &lt;code>compile_commands.json&lt;/code> file to work properly - this file contains translated output from your build system, that tells Clangd how the project is built. Thanks to that, Clangd can automatically detect the configuration you&amp;rsquo;re using and you doesn&amp;rsquo;t have to manually set anything up, unlike in default language server, where you&amp;rsquo;d have to set the include directories, flags and toolchain manually in JSON file.&lt;/p>
&lt;p>There are few ways to generate &lt;code>compile_commands.json&lt;/code>. As i&amp;rsquo;ve described in &lt;a href="https://steelph0enix.github.io/posts/vscode-cpp-setup/#bonus-clangd-setup">my previous blog post&lt;/a>, CMake generates this file automatically. However, we are not using CMake, so we have to use external tool for that. I&amp;rsquo;ve know of two, that i managed to get working without issues: &lt;a href="https://github.com/rizsotto/Bear">&lt;strong>Bear&lt;/strong>&lt;/a>, which supposedly works only on Linux, but apparently there is a version available in &lt;code>winget&lt;/code> repository, and &lt;a href="https://github.com/nickdiego/compiledb">&lt;strong>compiledb&lt;/strong>&lt;/a> which should work anywhere, and is written in Python, so you need it installed to use it. &lt;strong>Note: install &lt;code>compiledb&lt;/code> IN USER DIRECTORY (&lt;code>python3 -m pip install --user compiledb&lt;/code>), because it may not work when installed globally due to permission issues! If you encounter permission-related issues, make sure all of it&amp;rsquo;s dependencies are installed in user directories too! And make sure it&amp;rsquo;s in your PATH variable! Same goes for Bear.&lt;/strong>&lt;/p>
&lt;p>The usage of these tools is simple: you run them with your build command, so they take it&amp;rsquo;s output and convert it to Clangd&amp;rsquo;s &lt;code>compile_commands.json&lt;/code>. In case of Bear, you also have to make clean-build (run &lt;code>make clean&lt;/code> before running it), which makes it troublesome to integrate with our setup, so i&amp;rsquo;m going to use &lt;code>compiledb&lt;/code> here.&lt;/p>
&lt;p>To build the project and generate the &lt;code>compile_commands.json&lt;/code>, run &lt;code>compiledb make -j8&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>Tip: You can tell &lt;code>make&lt;/code> to build using multiple threads with &lt;code>-j&lt;/code> argument. This will &lt;strong>significantly&lt;/strong> decrease compilation time. For example: &lt;code>make -j8&lt;/code> will build the program using 8 threads. Modify this argument according to your CPU capabilities (amount of cores and thread per core).&lt;/p>
&lt;/blockquote>
&lt;p>Compiledb will run &lt;code>make&lt;/code> and pass all the arguments to it, &lt;code>-j8&lt;/code> in our case. After running this command from the project root, the &lt;code>compile_commands.json&lt;/code> should appear there. Open any &lt;code>*.c&lt;/code> or &lt;code>*.h&lt;/code> file, or re-open, if you opened them already, and check if the language server works - you should now see no errors related to missing includes or unrecognized function, see the tooltips for code on hover, and have all the other language-server-related features working.&lt;/p>
&lt;p>&lt;img alt="clangd-working" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/clangd-working.png">&lt;/p>
&lt;h4 id="configuring-standard-library-visibility">Configuring standard library visibility&lt;/h4>
&lt;p>After playing with &lt;code>clangd&lt;/code> a bit more in this project, i found out that even though project builds successfully when i use standard library, clangd doesn&amp;rsquo;t recognize it&amp;rsquo;s headers for some reason. I suppose it&amp;rsquo;s because the target platform is not the native one, so it doesn&amp;rsquo;t know where to look for headers. I&amp;rsquo;ve fixed it by adding include path with stdlib headers to &lt;code>C_INCLUDES&lt;/code> variable in Makefile, and clean-building the project.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># C includes
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>C_INCLUDES &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-ICore/Inc &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/STM32G4xx_HAL_Driver/Inc &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/STM32G4xx_HAL_Driver/Inc/Legacy &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/CMSIS/Device/ST/STM32G4xx/Include &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>-IDrivers/CMSIS/Include &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">-I/usr/arm-none-eabi/include&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="flashing-the-binary">Flashing the binary&lt;/h3>
&lt;p>We&amp;rsquo;ll create a rule in Makefile to flash our program to MCU. You could do this as VSCode task too, if you&amp;rsquo;d like, with slight modifications.
Open the &lt;code>Makefile&lt;/code>, and somewhere on the bottom, before EOF marker, add a new rule that will run OpenOCD:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-make" data-lang="make">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">flash&lt;/span>&lt;span style="color:#f92672">:&lt;/span> all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> openocd -f interface/stlink.cfg -f target/stm32g4x.cfg -c &lt;span style="color:#e6db74">&amp;#34;program &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>BUILD_DIR&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>TARGET&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">.elf verify reset exit&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>If you are not using ST-Link, change the interface config file to proper one. Same applies to MCU config file - switch it to one that&amp;rsquo;s for MCU you&amp;rsquo;re working on.&lt;/strong> All the configuration files are stored in OpenOCD installation directory. If you&amp;rsquo;re on Linux, they should be stored in &lt;code>/usr/share/openocd/&lt;/code> by default.
The rest of this command tells OpenOCD what to do - program the specific ELF file to MCU flash memory, verify the memory integrity, reset the MCU and exit.
It also requires &lt;code>all&lt;/code> rule, so the project will build itself automatically and upload the ELF file to MCU every time you run &lt;code>make flash&lt;/code> now. &lt;strong>This does NOT dissapear during CubeMX project re-generation, so you don&amp;rsquo;t have to worry about copy&amp;amp;pasting it every time you do this&lt;/strong>.
To delete all the build files (to do a clean build for example), use &lt;code>make clean&lt;/code> command.&lt;/p>
&lt;h3 id="configuring-vscode-tasks">Configuring VSCode tasks&lt;/h3>
&lt;p>To get some degree of automation, we&amp;rsquo;ll create VSCode tasks for building, cleaning and flashing the project. Open command prompt in VSCode (&lt;code>Ctrl+Shift+P&lt;/code>), and look for &lt;code>Tasks: Configure Default Build Task&lt;/code> command (or &lt;code>Task: Configure Task&lt;/code>).&lt;/p>
&lt;p>&lt;img alt="create-build-task-1" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-1.png">&lt;/p>
&lt;p>Then, select &lt;code>Create tasks.json file from template&lt;/code>, and select &lt;code>Others&lt;/code> template.&lt;/p>
&lt;p>&lt;img alt="create-build-task-2" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-2.png">
&lt;img alt="create-build-task-3" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-3.png">&lt;/p>
&lt;p>After that, you should see this &lt;code>tasks.json&lt;/code> file, which happened to be added to &lt;code>.vscode&lt;/code> directory in project root. If you&amp;rsquo;re using VCS (Git or Mercurial for example), you should be able to store it in repository without any issues, so don&amp;rsquo;t wildcard out the entire &lt;code>.vscode&lt;/code> directory in your &lt;code>.gitignore&lt;/code> (or any other VCS-related ignorefile) to keep the tasks.&lt;/p>
&lt;p>&lt;img alt="create-build-task-4" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/make-build-task-4.png">&lt;/p>
&lt;p>Copy this task and modify label and command accordingly, to create a build, clean and flash task. After that, run &lt;code>Tasks: Configure Default Build Task&lt;/code> command again, and select your build task. &lt;strong>Remember that we&amp;rsquo;re using &lt;code>Bear&lt;/code>/&lt;code>compiledb&lt;/code> to generate compilation database for Clangd! Don&amp;rsquo;t call &lt;code>make&lt;/code> for building the project directly, to always have updated and correct database!&lt;/strong> Now, your &lt;code>tasks.json&lt;/code> file should look similar to this (change the thread amount accordingly to your CPU capabilities):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// See https://go.microsoft.com/fwlink/?LinkId=733558
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// for the documentation about the tasks.json format
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tasks&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;label&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Build&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;shell&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;command&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;compiledb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;args&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;make&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;-j8&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;problemMatcher&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;group&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;build&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;isDefault&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;label&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Build &amp;amp; Flash&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;shell&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;command&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;compiledb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;args&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;make&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;flash&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;-j8&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;label&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Clean&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;shell&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;command&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;make&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;args&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;clean&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Test the tasks out by running &lt;code>Clean&lt;/code> task (&lt;code>Tasks: Run Task&lt;/code> command -&amp;gt; select &lt;code>Clean&lt;/code> task -&amp;gt; don&amp;rsquo;t scan the output, if you&amp;rsquo;re asked for that), and using &lt;code>Tasks: Run Build Task&lt;/code> shortcut - &lt;code>Ctrl+Shift+B&lt;/code>. The program should first clean, then build itself, and you should see &lt;code>make&lt;/code> output in integrated console window.&lt;/p>
&lt;p>&lt;img alt="task-output" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/task-output.png">&lt;/p>
&lt;p>Make a backup of this &lt;code>tasks.json&lt;/code> file, because it should be exactly the same for every project configured this way.
Also, reminder: instead of putting &lt;code>openocd&lt;/code> call in &lt;code>Makefile&lt;/code>, you can do it directly in VSCode task if you want - just split the arguments correctly (the command after &lt;code>-c&lt;/code> should be a single argument), and set the &lt;code>Build&lt;/code> task as &lt;code>Flash&lt;/code> task dependency &lt;a href="https://code.visualstudio.com/docs/editor/tasks#_compound-tasks">with &lt;code>dependsOn&lt;/code> list option&lt;/a>. You can also create a flash-only task like that. It&amp;rsquo;s up to your preference.&lt;/p>
&lt;h3 id="configuring-the-debugger">Configuring the debugger&lt;/h3>
&lt;p>Time to configure the debugging task. Go to the debug tab, and click on &lt;code>create a launch.json file&lt;/code>. Then, from the list, select &lt;code>Cortex Debug&lt;/code> option.&lt;/p>
&lt;p>&lt;img alt="debug-task-1" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-task-1.png">&lt;/p>
&lt;p>You should now have this file created, with default task for Cortex Debug plugin. We&amp;rsquo;ll have to change few things to make it working with OpenOCD, our debugger and MCU.&lt;/p>
&lt;p>&lt;img alt="debug-task-2" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-task-2.png">&lt;/p>
&lt;p>First, we&amp;rsquo;ll have to change the path to &lt;code>executable&lt;/code>, so it points to the &lt;code>elf&lt;/code> file with our program, which is in &lt;code>${workspaceRoot}/build/&lt;/code> directory. Then, we have to change &lt;code>servertype&lt;/code> to &lt;code>openocd&lt;/code>. It&amp;rsquo;s not the only debugger that Cortex Debug can use, you can see the whole list by calling autocompletion in empty field. Most of them should work with STM32, but i&amp;rsquo;ll focus on OpenOCD.&lt;/p>
&lt;p>&lt;img alt="debug-task-3" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-task-3.png">&lt;/p>
&lt;p>Then, we have to configure some OpenOCD-related stuff. We have to specify &lt;code>device&lt;/code>, and put the microcontroller name in it (without &lt;code>Tx&lt;/code> suffix, which corresponds to the temperature version of chip: for example, i&amp;rsquo;m using &lt;code>STM32G474RET6&lt;/code>, but in &lt;code>device&lt;/code> i have to put only &lt;code>STM32G474RE&lt;/code>, because all the temperature versions have exactly the same silicon inside). We also have to specify the configuration files for OpenOCD - the same ones that we specified for flashing. You can do it via &lt;code>configFiles&lt;/code> list.&lt;/p>
&lt;p>You should also specify &lt;code>preLaunchTask&lt;/code>, so VSCode will &lt;strong>always&lt;/strong> build and flash the binary before starting debug session. It&amp;rsquo;s important, because if you&amp;rsquo;d forget about it and start debugging session with different program on MCU than on your PC, debugger - at some point - will start showing you complete junk and unreasonable code flow, and if you are not aware of that, you will probably spend &lt;strong>a lot&lt;/strong> of time thinking what&amp;rsquo;s wrong with your code or MCU.&lt;/p>
&lt;p>The &lt;code>launch.json&lt;/code> file content should now look like this, except the &lt;code>device&lt;/code> and target config files should conform to MCU and debugger you&amp;rsquo;re using, &lt;code>preLaunchTask&lt;/code> should have the same name as your flash task, and &lt;code>executable&lt;/code> should point to your ELF file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Use IntelliSense to learn about possible attributes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// Hover to view descriptions of existing attributes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;version&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.2.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;configurations&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Cortex Debug&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;cwd&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${workspaceRoot}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;executable&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${workspaceRoot}/build/blog-vscode-cubemx-example.elf&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;request&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;launch&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cortex-debug&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;servertype&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;openocd&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;device&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;STM32G474RE&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;configFiles&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;interface/stlink.cfg&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;target/stm32g4x.cfg&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;preLaunchTask&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Build &amp;amp; Flash&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If everything has been configured correctly, you should be able to debug your program now. Add a breakpoint in the first line of &lt;code>main&lt;/code> function (click left to line number, red dot should appear) and run the debugging session (&lt;code>F5&lt;/code> by default, or click a button on top of Debug menu).&lt;/p>
&lt;p>&lt;img alt="debug-session" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/debug-session.png">&lt;/p>
&lt;p>VSCode should switch to debug perspective, and you should be able to see variables/objects (expand Global section), call stack, and add variables/objects to the watch. You should also be able to step through the program - either via controls on top, or keyboard shortcuts (&lt;code>F5&lt;/code> to let the program run until the next breakpoint, &lt;code>F10&lt;/code> to step over current line, &lt;code>F11&lt;/code> to step into current line, &lt;code>Shift+F11&lt;/code> to step out of current scope, &lt;code>Ctrl+Shift+F5&lt;/code> to restart debugging session, and &lt;code>Shift+F5&lt;/code> to stop debugging session). There&amp;rsquo;s also a button to reset the MCU (first from left).&lt;/p>
&lt;h4 id="configuring-the-peripheral-view">Configuring the peripheral view&lt;/h4>
&lt;p>Finally, to see all the peripherals of our MCU and their registers content, we can download and specify SVD (or rather, to be precise, CMSIS-SVD - System View Description) file. &lt;strong>This step is optional, but being able to see the peripherals is useful, so i recommend doing this anyway&lt;/strong>. For ST MCU&amp;rsquo;s, you can get SVD files from the MCU page on st.com. For example, in case of my MCU i go &lt;a href="https://www.st.com/en/microcontrollers-microprocessors/stm32g474re.html">here&lt;/a>, into &lt;code>CAD Resources&lt;/code> tab, and i download &lt;code>STM32G4 System view description&lt;/code> (ST account not required).&lt;/p>
&lt;p>&lt;img alt="svd-config-1" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/svd-config-1.png">&lt;/p>
&lt;p>After that, i unpack it. Inside unpacked archive, there should be a directory wih &lt;code>*.svd&lt;/code> files - find one compatible with your MCU (in my case it&amp;rsquo;s named &lt;code>STM32G474xx.svd&lt;/code>) and copy it to project root directory. Now, open &lt;code>launch.json&lt;/code> and add new option in debug configuration:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;svdFile&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;${workspaceRoot}/STM32G474xx.svd&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Of course, change the name of the file to correct one. To check if it&amp;rsquo;s working, start debug session (&lt;code>F5&lt;/code>) and look for &lt;code>Cortex Peripherals&lt;/code> section in debug view. Open it and check if you can see the peripherals, along with their addresses, registers and register fields content.&lt;/p>
&lt;p>&lt;img alt="peripherals-view" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/peripherals-view.png">&lt;/p>
&lt;p>And that&amp;rsquo;s all. If you did all the steps, and verified they&amp;rsquo;re working, congratulations - you now have an alternative for CubeIDE for STM32 development with CubeMX, that isn&amp;rsquo;t very painful to configure and has most of the features you&amp;rsquo;ll need. I&amp;rsquo;ve heard that Cortex Debug also allows to configure ITM output, but i haven&amp;rsquo;t tried that yet, so i&amp;rsquo;ll probably describe it in different blog post in the future.&lt;/p>
&lt;p>Now, for the bonus part&amp;hellip;&lt;/p>
&lt;h2 id="stm32-hal-vs-ll-libraries-and-how-to-change-between-them-in-cubemx">STM32 HAL vs LL libraries, and how to change between them in CubeMX&lt;/h2>
&lt;p>If you&amp;rsquo;re using CubeMX for STM32 projects, you are (most probably) inherently using HAL libraries to work with the MCU. HAL is an Hardware Abstraction Layer - set of libraries which abstract operations on the hardware, that are easy to use for someone who doesn&amp;rsquo;t want to dig through the manual to do even simplest things. Also worth mentioning, that STM32 HAL is &lt;em>mostly&lt;/em> the same under all STM32 MCUs, therefore moving project that relies on HAL between different STM32 MCUs in the same family, or even between different families of STM32 MCUs, is fairly easy. However, it do have some issues - mainly, the memory bloat that&amp;rsquo;s sometimes really noticable (especially on low-end MCUs with very little memory - some of them even can&amp;rsquo;t use HAL at all, because it takes more memory than they have for simple project with just the initialization code). It can also be slower than dedicated solutions, due to handling almost everything that can happen every time.&lt;/p>
&lt;p>The solution of these issues doesn&amp;rsquo;t have to be throwing away CubeMX, and going back to the registers and CMSIS level, writing everything manually. There is an alternative - Low Layer libraries. These exist for all the peripherals that don&amp;rsquo;t require upper-level stack (like USB or Ethernet), and are significantly lighter than HAL. However, they are also more complicated to use, as they don&amp;rsquo;t cover the functionality as HAL libraries do. LL offers a low-level API that&amp;rsquo;s just above the registers. In other words, LL is an almost unnoticeable (performance and memory-wise) layer that abstracts the registers away, giving you fairly well documented and more readable API instead, that doesn&amp;rsquo;t take away much control from you.&lt;/p>
&lt;p>To learn about HAL and LL differences in detail, i suggest going to CubeMX package site for your STM32 MCU (in my case: &lt;a href="https://www.st.com/en/embedded-software/stm32cubeg4.html">this one&lt;/a>), into &lt;code>Documentation&lt;/code> section, and reading User Manual called &lt;code>Description of STM32XY HAL and low-layer drivers&lt;/code>, where &lt;code>XY&lt;/code> symbolize you series. You can find full documentation of both HAL and LL libraries there, along with their philosophy.&lt;/p>
&lt;p>There is an easy way of changing between HAL and LL drivers in CubeMX: open the project and go to &lt;code>Project Manager -&amp;gt; Advanced Settings&lt;/code>.&lt;/p>
&lt;p>&lt;img alt="cubemx-hal-ll" src="https://steelph0enix.github.io/img/vscode-cubemx-setup/cubemx-hal-ll.png">&lt;/p>
&lt;p>You can do three things there:&lt;/p>
&lt;ul>
&lt;li>Change between HAL and LL drivers for every peripheral, and even every instance of peripheral;&lt;/li>
&lt;li>Configure the initialization order of used peripherals (very useful for issues with DMA, when it&amp;rsquo;s wrongly initialized after the peripheral that&amp;rsquo;s using it);&lt;/li>
&lt;li>Enable or disable callback registration per peripheral (as an alternative to global interrupt callbacks).&lt;/li>
&lt;/ul>
&lt;p>While you still might not want to use LL, it&amp;rsquo;s a good idea to take a look there if you look for memory to free. For example, if you are not using any peripheral-related functions in code, yet you need that peripheral initialized (which can be a case for RCC for example), you can switch it from HAL to LL to save few bytes of memory without touching the code yourself. &lt;strong>But remember: HAL and LL functions ARE NOT inter-compatible. You CANNOT use both HAL and LL for the same peripheral at the same time (without proper precautions), as HAL requires a handle that&amp;rsquo;s state reflects the current state of peripheral. If you start using non-HAL code along with HAL, you HAVE TO make sure the state in HAL handle will not be invalid when HAL functions are being called (in interrupts that use HAL handlers too!), otherwise HAL code can break the program.&lt;/strong>&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>And that would be it. Thank you for reading, and if you have questions or issues, feel free to &lt;a href="https://steelph0enix.github.io/about/">contact me&lt;/a> or drop an issue/pull request in &lt;a href="https://github.com/SteelPh0enix/steelph0enix.github.io">the blog&amp;rsquo;s repository&lt;/a>.&lt;/p></content></item><item><title>Visual Studio Code - C/C++ Setup</title><link>https://steelph0enix.github.io/posts/vscode-cpp-setup/</link><pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate><guid>https://steelph0enix.github.io/posts/vscode-cpp-setup/</guid><description>&lt;p>Visual Studio Code is a great open-source editor with plenty of useful plugins for insane amount of languages and frameworks.&lt;/p>
&lt;p>However, as C and C++ environment is pretty janky for today&amp;rsquo;s standards, so is the configuration. So i made this guide to streamline the process and make it easy for somebody new in C, C++ or VSCode to setup a reasonably working dev environment with some useful quality-of-life tools. It might not be IntelliJ-level of quality, but hey - it&amp;rsquo;s free.&lt;/p></description><content>&lt;p>Visual Studio Code is a great open-source editor with plenty of useful plugins for insane amount of languages and frameworks.&lt;/p>
&lt;p>However, as C and C++ environment is pretty janky for today&amp;rsquo;s standards, so is the configuration. So i made this guide to streamline the process and make it easy for somebody new in C, C++ or VSCode to setup a reasonably working dev environment with some useful quality-of-life tools. It might not be IntelliJ-level of quality, but hey - it&amp;rsquo;s free.&lt;/p>
&lt;p>In this guide, i will tell you:&lt;/p>
&lt;ul>
&lt;li>What tools you&amp;rsquo;ll need to start developing C and C++ apps in VSCode&lt;/li>
&lt;li>What extensions you might want to install to ease up the code writing process, and how to configure them&lt;/li>
&lt;li>How do you create a C/C++ project in VSCode (with CMake) and integrate it with VSCode&lt;/li>
&lt;/ul>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;h3 id="vscode">VSCode&lt;/h3>
&lt;p>The obvious prerequisite is Visual Studio Code. Install it from the official site: &lt;a href="https://code.visualstudio.com/">https://code.visualstudio.com/&lt;/a>, or from a repository if you&amp;rsquo;re using a package manager.&lt;/p>
&lt;p>&lt;strong>For Windows&lt;/strong>: either download the installer from official site and run it, or install VSCode via &lt;a href="https://scoop.sh/">scoop&lt;/a>: &lt;code>scoop install vscode&lt;/code>. &lt;em>btw; i strongly recommend &lt;code>scoop&lt;/code> - great package manager&lt;/em>&lt;/p>
&lt;p>&lt;strong>For Linux&lt;/strong>: if you have it in your package manager repository, install it from there. Otherwise, use the installer from official site.&lt;/p>
&lt;p>&lt;strong>For MacOS&lt;/strong>: same as for Linux. Probably. I don&amp;rsquo;t use MacOS so i can&amp;rsquo;t really tell.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Fun fact&lt;/strong>; there are two versions of VSCode you can find on the internet and in package managers - OSS version, and Non-OSS. The OSS version is basically the VSCode you&amp;rsquo;d get by downloading it from &lt;a href="https://github.com/microsoft/vscode">official repository&lt;/a> and building it yourself. Non-OSS version is the one from Microsoft distribution (for example, their official site), and the only difference between them is that Non-OSS version uses some Microsoft propertiary code, while OSS doesn&amp;rsquo;t. There is some functional difference (IIRC, OSS version lacks proprietary features like Settings Sync or Remote WSL/SSH/Containers), but both are fully compatible in terms of plugins and configuration, so you usually don&amp;rsquo;t need to worry about the exact version you&amp;rsquo;ve installed.&lt;/p>
&lt;/blockquote>
&lt;h3 id="cc-toolchain">C/C++ Toolchain&lt;/h3>
&lt;p>There are many C/C++ toolchains available, and i&amp;rsquo;m not gonna enforce one, because this guide is mostly toolchain-independent (in the end we&amp;rsquo;re gonna use build system, but most of the examples are for GCC). However, if you are new to C/C++, i&amp;rsquo;d recommend starting with GCC (or MinGW, if you&amp;rsquo;re on Windows) as it&amp;rsquo;s easy to install and use out of the box.&lt;/p>
&lt;p>If you already have your preferred toolchain installed and configured, feel free to go to the next step. If not, here&amp;rsquo;s the guide:&lt;/p>
&lt;p>&lt;strong>For Windows&lt;/strong>:&lt;/p>
&lt;p>My usual way of installing C++ toolchain on Windows is via &lt;a href="https://winlibs.com/">WinLibs&lt;/a> package. To install it:&lt;/p>
&lt;ul>
&lt;li>Download latest UCRT runtime version for Win64 (i assume you&amp;rsquo;re running at least Win10 64bit, otherwise read the instructions on WinLibs page). &lt;img alt="winlibs download" src="https://steelph0enix.github.io/img/vscode-cpp-setup/winlibs_download.png">&lt;/li>
&lt;li>Extract it somewhere - preferably directly to a hard drive, for example &lt;code>C:\&lt;/code>, but it can be anywhere. I recommend avoiding paths with spaces and non-ASCII characters though, they may cause headaches in the future. &lt;img alt="mingw unzipped" src="https://steelph0enix.github.io/img/vscode-cpp-setup/mingw_unzipped.png">&lt;/li>
&lt;li>Add &lt;code>/bin&lt;/code> subdirectory to system or user &lt;code>PATH&lt;/code> variable. &lt;img alt="env vars" src="https://steelph0enix.github.io/img/vscode-cpp-setup/env_vars.png">&lt;/li>
&lt;li>Open terminal and run &lt;code>gcc --version&lt;/code> command. You should see similar message to the one below. You may also want to run &lt;code>where.exe gcc&lt;/code> to make sure you&amp;rsquo;re using correct GCC executable, in case you&amp;rsquo;d have other GCC installation in the system that you forgot about - usually, WinLibs provides most recent one, so this is the one you should be using. &lt;img alt="check install" src="https://steelph0enix.github.io/img/vscode-cpp-setup/gcc_version.png">&lt;/li>
&lt;/ul>
&lt;p>If you&amp;rsquo;d rather use different toolchain than GCC, i recommend Visual C++, which you can install via Build Tools for Visual Studio 2022. You can download it from &lt;a href="https://aka.ms/vs/17/release/vs_BuildTools.exe">here&lt;/a>. To install C++ toolchain, run the installer and select the option &amp;ldquo;Desktop development with C++&amp;rdquo;. &lt;img alt="msvc install" src="https://steelph0enix.github.io/img/vscode-cpp-setup/msvc_cpp.png">
Note that &lt;strong>you don&amp;rsquo;t need both toolchains, one is enough&lt;/strong>, and that build tools do not include Visual Studio - if you want Visual Studio, you can install it as separate product using the same installer. Since this guide is about &lt;strong>Visual Studio Code&lt;/strong>, which is a different product, i&amp;rsquo;m not going to provide instructions for that.&lt;/p>
&lt;p>&lt;strong>For Linux&lt;/strong>:&lt;/p>
&lt;p>Usually, you should have GCC in your repository. On Ubuntu, Debian and similar distributions (Mint, Kubuntu, Lubuntu, PopOS!, Zorin, and so on), you have &lt;code>build-essential&lt;/code> package with most tools needed to build C/C++ programs.&lt;/p>
&lt;p>On Arch Linux and similar distributions (Manjaro), you have &lt;code>base-devel&lt;/code> package.&lt;/p>
&lt;p>On other distributions, search for similar package or install latest &lt;code>gcc&lt;/code> and &lt;code>g++&lt;/code> packages from your repository.&lt;/p>
&lt;p>Test it the same way as on Windows - open terminal and try &lt;code>gcc --version&lt;/code>, see what happens.&lt;/p>
&lt;p>&lt;strong>You also have to install &lt;code>gdb&lt;/code> (GCC debugger) separately, as it may not come with the base development packages, and you definitely do want to have it and use it.&lt;/strong>&lt;/p>
&lt;p>&lt;strong>For MacOS&lt;/strong>: probably same thing as on Linux, look for GCC (or any other preferred toolchain) in package manager and install it from there. Verify the installation the same way as on Linux.&lt;/p>
&lt;h2 id="vscode-essential-plugins">VSCode Essential Plugins&lt;/h2>
&lt;p>If you already have working C/C++ toolchain, time to run VSCode and install some plugins. Run VSCode and go to the &lt;em>Extensions&lt;/em> menu.&lt;/p>
&lt;p>&lt;img alt="vsc-ext-1" src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-ext-1.png">&lt;/p>
&lt;p>Now, for some general C++ plugins:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>C/C++&lt;/strong> - that&amp;rsquo;s the core extension we&amp;rsquo;ll need. It contains the fundamental stuff to work with C/C++ in VSCode.&lt;/li>
&lt;li>&lt;strong>Better C++ Syntax&lt;/strong> - it&amp;rsquo;s always nice to have better syntax colouring, so i strongly recommend that one. &lt;em>You might want to use one of the themes from this extension description to get full experience.&lt;/em>&lt;/li>
&lt;li>&lt;strong>C/C++ Snippets&lt;/strong> - pretty useful extension that adds automatic generation of snippets in C/C++ code - instead of writing loops, structures and class definitions by hand, you can generate them with autocompletion support.&lt;/li>
&lt;li>&lt;strong>C++ Intellisense&lt;/strong> - pretty good plugin with some intelligent autocompletion features.&lt;/li>
&lt;li>&lt;strong>C++ Helper&lt;/strong> - simple extension which adds automatic function definition generation feature.&lt;/li>
&lt;li>&lt;strong>C-mantic&lt;/strong> - very useful plugin that adds auto-generation of function definitions, getters, setters and more. &lt;strong>An alternative to C++ Helper - pick whatever seems more ergonomic for you&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>And i&amp;rsquo;d also recommend these:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Bracket Pair Colorizer 2&lt;/strong> - very useful extension which colorize the matching bracket pairs, increasing code clarity. Strongly recommended.&lt;/li>
&lt;li>&lt;strong>GitLens&lt;/strong> - if you want to work with Git repositories, that&amp;rsquo;s the extension you&amp;rsquo;re looking for. &lt;strong>You need &lt;code>git&lt;/code> installed to use it!&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Material Icon Theme&lt;/strong> - better looking than default ones&lt;/li>
&lt;/ul>
&lt;p>With these plugins, you will have a pretty decent bare-bones environment to work with C and C++. You&amp;rsquo;ll have autocompletion, some refactoring features, some code generation and a pretty decent syntax highlighting. &lt;em>The screenshot below is outdated - use the list above for updated recommended plugins&lt;/em>&lt;/p>
&lt;p>&lt;img alt="installed-ext" src="https://steelph0enix.github.io/img/vscode-cpp-setup/installed-ext-vscode.png">&lt;/p>
&lt;blockquote>
&lt;p>I have one more plugin to show you, an alternative language server with many useful features, but i&amp;rsquo;ll leave it as a bonus at the end of this guide, because it needs a bit more configuration. Make sure to check it out!&lt;/p>
&lt;/blockquote>
&lt;h2 id="creating-a-project---vscode-and-cmake">Creating a project - VSCode and CMake&lt;/h2>
&lt;p>We&amp;rsquo;ll start with something simple. As i&amp;rsquo;ve mentioned before, i&amp;rsquo;m not gonna teach you how to make a &lt;em>raw&lt;/em> VSCode project, which builds the app from scratch and without any other tools, because that&amp;rsquo;s simply painful, not really scalable, and not worth the trouble.&lt;/p>
&lt;p>Instead, i&amp;rsquo;m gonna teach you how to use a build system.&lt;/p>
&lt;h3 id="but-whats-a-build-system">But what&amp;rsquo;s a &lt;em>build system&lt;/em>?&lt;/h3>
&lt;p>Well, build system is a tool that tells the toolchain (compiler and his friends) how to create a program out of all the source (and resource) files you&amp;rsquo;ve created. And sometimes does other things, but that&amp;rsquo;s out of this tutorial scope.&lt;/p>
&lt;p>Without it, you&amp;rsquo;d have to enter the toolchain commands manually each time you&amp;rsquo;d want to build the application. That&amp;rsquo;s fine for small apps with one, two or maybe five files. But it gets messy when your program starts to grow.&lt;/p>
&lt;p>So, for example, assuming you use &lt;code>gcc&lt;/code>, to build your C program manually, you&amp;rsquo;d have to enter something like this:&lt;/p>
&lt;p>&lt;code>gcc [list of your source files] [some fancy flags for your compiler] [maybe some flags telling the compiler where the libraries are] -o program.exe&lt;/code>&lt;/p>
&lt;p>An actual example would be:&lt;/p>
&lt;p>&lt;code>gcc main.c lib.c lib2.c -O2 -Wall -Wextra -L./some/lib -lmylib -lsomeotherlib -o program.exe&lt;/code>&lt;/p>
&lt;p>That doesn&amp;rsquo;t look so bad, right? You could even put this command in some shell script and easily run it every time you&amp;rsquo;d like to build the code. But then, you&amp;rsquo;d have to change this command every time your project structure changes - so, every time you add a new file, or library, or change some directory name, you gotta edit this script. &lt;em>And yes, i know that wildcards exist, but for the sake of this example i&amp;rsquo;m gonna ignore them.&lt;/em>&lt;/p>
&lt;p>Another issue is that if you&amp;rsquo;d want to give this code to your friend or teacher, he would either have to use the same shell as you, and &lt;code>gcc&lt;/code>, or write his own build script (or project) for the compiler/shell he&amp;rsquo;s using, and that&amp;rsquo;s not very user-friendly (or, rather, programmer-friendly) solution.&lt;/p>
&lt;p>There are also some other issues with manual building, but the point is: &lt;strong>manual building is not comfortable or scalable on a larger scale&lt;/strong>. So, we&amp;rsquo;ll use a build system to do it for us and make everyone&amp;rsquo;s life easier!&lt;/p>
&lt;p>&lt;em>Bonus note: Tool i&amp;rsquo;m going to talk about next - CMake - isn&amp;rsquo;t technically a build system. It&amp;rsquo;s a meta-build system. The difference between those is that build system runs the toolchain commands directly, while meta-build system generates the build system files. Basically, meta-build systems are more flexible, and sometimes easier to use, therefore we&amp;rsquo;re gonna use one.&lt;/em>&lt;/p>
&lt;p>&lt;em>Bonus note number two: originally, i was going to show how to use Premake and CMake, but due to some &lt;a href="https://github.com/premake/premake-core/issues/1640">pretty bad issues with Premake&lt;/a> i&amp;rsquo;ve decided to stay with CMake. I&amp;rsquo;ll probably make a Premake guide in the future.&lt;/em>&lt;/p>
&lt;h4 id="okay-how-do-i-use-it">Okay, how do i use it?&lt;/h4>
&lt;p>Well, let&amp;rsquo;s start with installation. You can either install it from your package manager, just like VSCode, or download from &lt;a href="https://cmake.org/download/">official site&lt;/a>. &lt;strong>Make sure to add CMake to your PATH variable if you&amp;rsquo;re using an official installer!&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>Important note: if you&amp;rsquo;re using your package manager, check the CMake version after installation (&lt;code>cmake --version&lt;/code> command). I&amp;rsquo;m gonna use some stuff that was added in CMake 3.12, but from what i can see, some older Linux distributions (like Ubuntu 18.04) &lt;a href="https://packages.ubuntu.com/search?keywords=cmake">still have CMake 3.10 in their repositories&lt;/a>, so if that&amp;rsquo;s the case i strongly recommend installing newer version manually. If that&amp;rsquo;s not possible, i&amp;rsquo;ll tell what things come from CMake 3.12 and how to make a workaround.&lt;/p>
&lt;/blockquote>
&lt;p>Done? Great. Now a little bit of theory.&lt;/p>
&lt;h4 id="how-does-cmake-work">How does CMake work?&lt;/h4>
&lt;p>CMake is a meta-build system. As i&amp;rsquo;ve mentioned earlier, it means that when we run it, it should give us a project for a build system of our choice, which we can use to build our application. To tell CMake how it should generate the project, a &lt;code>CMakeLists.txt&lt;/code> file is used. This file includes the project configuration, written in CMake&amp;rsquo;s scripting language.&lt;/p>
&lt;p>Some toolchains - like GCC, MinGW or Visual C++ - come with their own build systems. In case of GCC/MinGW, it&amp;rsquo;s GNU Make. In case of Visual C++, it&amp;rsquo;s MSBuild. CMake can generate the necessary files for these build systems, and then we can use them to build the whole project with a single command. Pretty convenient.&lt;/p>
&lt;h3 id="creating-a-simple-project">Creating a simple project&lt;/h3>
&lt;p>Let&amp;rsquo;s open VSCode (or restart, if you had it opened while installing CMake) and add some extensions.&lt;/p>
&lt;p>&lt;img alt="cmake-ext" src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-ext.png">&lt;/p>
&lt;p>These two plugins will enable &lt;code>CMakeLists.txt&lt;/code> syntax highlighting and CMake integration for VSCode. And this integration is a very powerful and helpful tool, as we&amp;rsquo;ll see in a bit. &lt;em>You can also install a &lt;code>cmake-format&lt;/code> extension, if you have Python installed and follow the &lt;a href="https://marketplace.visualstudio.com/items?itemName=cheshirekow.cmake-format">plugin&amp;rsquo;s installation guide&lt;/a>&lt;/em>&lt;/p>
&lt;p>Now, make a folder for our new project and create a simple &lt;code>main.cpp&lt;/code> (or &lt;code>main.c&lt;/code>, if you want to code in C):&lt;/p>
&lt;p>C++ version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, world!&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, world!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can check if your toolchain works correctly by building the app manually. If you&amp;rsquo;re using GCC or MinGW, open up integrated VSCode terminal with &lt;code>Ctrl+` &lt;/code> command (or &lt;code>Ctrl+Shift+` &lt;/code> to create a new one), and run:&lt;/p>
&lt;p>C++: &lt;code>g++ main.cpp -o main&lt;/code>&lt;/p>
&lt;p>C: &lt;code>gcc main.c -o main&lt;/code>&lt;/p>
&lt;p>And then run the app with &lt;code>./main&lt;/code> command. You should see your Hello World printed in terminal.&lt;/p>
&lt;p>&lt;img alt="hello-world-manual" src="https://steelph0enix.github.io/img/vscode-cpp-setup/hello-world-first-run.png">&lt;/p>
&lt;p>&lt;em>If that doesn&amp;rsquo;t work, make sure you have correctly added your toolchain to PATH variable.&lt;/em>&lt;/p>
&lt;p>Now, we can proceed with CMake. Delete the compiled program &lt;code>main&lt;/code> you just created and tested, and create a &lt;code>CMakeLists.txt&lt;/code> file in the same directory as your code file. We&amp;rsquo;ll start with bare-bones template and then we&amp;rsquo;ll expand it a little.&lt;/p>
&lt;p>Put this code into &lt;code>CMakeLists.txt&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>cmake_minimum_required(&lt;span style="color:#e6db74">VERSION&lt;/span> &lt;span style="color:#e6db74">3.12&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change CXX to C, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>project(&lt;span style="color:#e6db74">HelloWorld&lt;/span> &lt;span style="color:#e6db74">LANGUAGES&lt;/span> &lt;span style="color:#e6db74">CXX&lt;/span>) &lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change main.cpp to main.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>add_executable(&lt;span style="color:#f92672">${&lt;/span>PROJECT_NAME&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#e6db74">main.cpp&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then open up the VSCode command list with &lt;code>Ctrl+Shift+P&lt;/code> shortcut, and look for &lt;code>CMake: Configure&lt;/code> option. Run it.&lt;/p>
&lt;p>&lt;img alt="cmake-config" src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-configure-cmd.png">&lt;/p>
&lt;p>Next, you should see a list of detected toolchains installed in your system. Pick one.&lt;/p>
&lt;p>&lt;img alt="cmake-select-kit" src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-select-kit.png">&lt;/p>
&lt;p>After that, VSCode will run CMake and configure the project for the first time. You should see similar output in your VSCode output window:&lt;/p>
&lt;p>&lt;img alt="cmake-config-out" src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-output.png">&lt;/p>
&lt;p>From now on, VSCode will automatically run CMake every time you change &lt;code>CMakeLists.txt&lt;/code> to re-generate the project files. You should also see a new menu on left-side toolbar&lt;/p>
&lt;p>&lt;img alt="cmake-menu" src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-menu.png">&lt;/p>
&lt;h4 id="building-your-program">Building your program&lt;/h4>
&lt;p>So, we have a project now. How do we build it, and how do we run our program?&lt;/p>
&lt;p>Thankfully, CMake plugin for VSCode got us covered. To build the program, either use &lt;code>F7&lt;/code> shortcut, look for the &lt;code>CMake: Build&lt;/code> command in command list, or press the &lt;code>Build&lt;/code> button either on VSCode bottom bar, or in CMake menu.&lt;/p>
&lt;p>&lt;img alt="build-from-bar" src="https://steelph0enix.github.io/img/vscode-cpp-setup/build-bottom-bar.png">&lt;/p>
&lt;p>&lt;img alt="build-from-menu" src="https://steelph0enix.github.io/img/vscode-cpp-setup/build-cmake-menu.png">&lt;/p>
&lt;p>You should see similar output in VSCode output window:&lt;/p>
&lt;p>&lt;img alt="build-output" src="https://steelph0enix.github.io/img/vscode-cpp-setup/build-output.png">&lt;/p>
&lt;h4 id="running-your-program">Running your program&lt;/h4>
&lt;p>Now, let&amp;rsquo;s run it. Press the &lt;code>Run&lt;/code> button on the bottom VSCode bar:&lt;/p>
&lt;p>&lt;img alt="run-app" src="https://steelph0enix.github.io/img/vscode-cpp-setup/run-bottom-bar.png">&lt;/p>
&lt;p>And the app should run without any issues. The output should be in terminal window.&lt;/p>
&lt;p>&lt;img alt="app-run" src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-run.png">&lt;/p>
&lt;h4 id="is-that-it">Is that it?&lt;/h4>
&lt;p>&lt;strong>Of course not - there&amp;rsquo;s always more!&lt;/strong>&lt;/p>
&lt;p>But yeah, we just created a very simple project with CMake + VSCode, built it and ran it. Now, let&amp;rsquo;s talk what actually happened and how can we expand our project.&lt;/p>
&lt;h2 id="cmake-101---how-does-it-work">CMake 101 - how does it work?&lt;/h2>
&lt;p>CMake, as i&amp;rsquo;ve mentioned multiple times, is a tool that generates the project files used to build it. However, it can also be used for some other things - like application packaging, managing tests, configuring the project, and so on. At the moment CMake is an &lt;em>industry standard&lt;/em>, which means that most of the C and C++ projects have CMake support, therefore it&amp;rsquo;s a very versatile tool. Not the best, but versatile.&lt;/p>
&lt;p>You may notice that after configuring the project a new directory appeared in your project folder, called &lt;code>build&lt;/code>. Let&amp;rsquo;s peek into it.&lt;/p>
&lt;p>&lt;img alt="cmake-build-dir" src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmake-build-dir.png">&lt;/p>
&lt;p>You are usually not supposed to touch and modify these files, as CMake manages them, but i&amp;rsquo;ll still explain the function of some of the more important ones:&lt;/p>
&lt;ul>
&lt;li>&lt;code>CMakeCache.txt&lt;/code> - inside that file, you can find a list of CMake variables that are used in project generation process. You can find the toolchain paths, compiler flags, user and many different configuration variables there.&lt;/li>
&lt;li>&lt;code>compile_commands.json&lt;/code> - that file contains a list of commands used to build your program. This list can be used by some code analyzing tools (and i&amp;rsquo;ll describe one at the end of this guide).&lt;/li>
&lt;li>&lt;code>HelloWorld.exe&lt;/code> - hey, that&amp;rsquo;s our program!&lt;/li>
&lt;li>&lt;code>Makefile&lt;/code> - this file is used by GNU Make to build our program. Basically, that&amp;rsquo;s the final CMake output. If you&amp;rsquo;re using a different toochain with different build system, like Visual C++, you will get a different file (usually, a whole Visual Studio solution, so maybe even a whole directory).&lt;/li>
&lt;/ul>
&lt;h3 id="cmakelists---whats-inside">CMakeLists - what&amp;rsquo;s inside?&lt;/h3>
&lt;p>Let&amp;rsquo;s analyze our &lt;code>CMakeLists.txt&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>cmake_minimum_required(&lt;span style="color:#e6db74">VERSION&lt;/span> &lt;span style="color:#e6db74">3.12&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change CXX to C, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>project(&lt;span style="color:#e6db74">HelloWorld&lt;/span> &lt;span style="color:#e6db74">LANGUAGES&lt;/span> &lt;span style="color:#e6db74">CXX&lt;/span>) &lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change main.cpp to main.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>add_executable(&lt;span style="color:#f92672">${&lt;/span>PROJECT_NAME&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#e6db74">main.cpp&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>cmake_minimum_required&lt;/code> defines the minimal version of CMake required to generate this project. We&amp;rsquo;ll use 3.12 because i&amp;rsquo;m gonna show you some stuff that was added in this version.&lt;/li>
&lt;li>&lt;code>project&lt;/code> defines our project. We can also add information about version, project description, homepage and used languages - which we do in that case.&lt;/li>
&lt;li>&lt;code>add_executable&lt;/code> tells CMake to generate a code that will build an executable file with specified name from specified source files. &lt;code>${PROJECT_NAME}&lt;/code> is a CMake variable containing the project name defined by &lt;code>project&lt;/code> command.&lt;/li>
&lt;/ul>
&lt;p>It&amp;rsquo;s important that &lt;code>add_executable&lt;/code> requires a full list of all the source files making up the program. So, in theory, you would have to add every single source file to the list manually, like that: &lt;code>add_executable(${PROJECT_NAME} main.cpp a.cpp b.cpp [...])&lt;/code>, but fortunately that&amp;rsquo;s not necessary. We can use &lt;code>file&lt;/code> command to generate that list for us.&lt;/p>
&lt;h3 id="expanding-our-project---adding-more-files">Expanding our project - adding more files&lt;/h3>
&lt;p>Let&amp;rsquo;s add some more files for our project. First, create two new directories - &lt;code>include&lt;/code> and &lt;code>src&lt;/code> in root project directory:&lt;/p>
&lt;p>&lt;img alt="src-include-dirs" src="https://steelph0enix.github.io/img/vscode-cpp-setup/src-include-dirs.png">&lt;/p>
&lt;p>Now, move the &lt;code>main.cpp&lt;/code> (or &lt;code>main.c&lt;/code>) to &lt;code>src&lt;/code> directory, and make a new file called &lt;code>lib.cpp&lt;/code> (or &lt;code>lib.c&lt;/code>) there. Put this code inside:&lt;/p>
&lt;p>C++ version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.hpp&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, i&amp;#39;m a library!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">x = &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, i&amp;#39;m a library!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">x = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then, add a &lt;code>lib.hpp&lt;/code> (or &lt;code>lib.h&lt;/code>) file inside &lt;code>include&lt;/code> directory. Put this inside:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pragma once
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The project should look like this now:&lt;/p>
&lt;p>&lt;img alt="project-expanded" src="https://steelph0enix.github.io/img/vscode-cpp-setup/project-new-files.png">&lt;/p>
&lt;p>Let&amp;rsquo;s update the &lt;code>CMakeLists.txt&lt;/code>.&lt;/p>
&lt;p>We&amp;rsquo;ll use two new commands now: &lt;code>file&lt;/code> and &lt;code>include_directories&lt;/code>. &lt;code>file&lt;/code> command will generate the list of source files, while &lt;code>include_directories&lt;/code> will tell our toolchain where to look for header files.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmake" data-lang="cmake">&lt;span style="display:flex;">&lt;span>cmake_minimum_required(&lt;span style="color:#e6db74">VERSION&lt;/span> &lt;span style="color:#e6db74">3.12&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change CXX to C, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>project(&lt;span style="color:#e6db74">HelloWorld&lt;/span> &lt;span style="color:#e6db74">LANGUAGES&lt;/span> &lt;span style="color:#e6db74">CXX&lt;/span>) &lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change *.cpp to *.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>file(&lt;span style="color:#e6db74">GLOB&lt;/span> &lt;span style="color:#e6db74">PROJECT_SOURCE_FILES&lt;/span> &lt;span style="color:#e6db74">CONFIGURE_DEPENDS&lt;/span> &lt;span style="color:#e6db74">src/*.cpp&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>include_directories(&lt;span style="color:#e6db74">include/&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Change main.cpp to main.c, if you&amp;#39;re making a C program
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>add_executable(&lt;span style="color:#f92672">${&lt;/span>PROJECT_NAME&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">${&lt;/span>PROJECT_SOURCE_FILES&lt;span style="color:#f92672">}&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>file(GLOB PROJECT_SOURCE_FILES CONFIGURE_DEPENDS src/*.cpp)&lt;/code> - this command generates the list of files from &lt;code>src&lt;/code> dir with &lt;code>.cpp&lt;/code> extension, and stores it in &lt;code>PROJECT_SOURCE_FILES&lt;/code> variable. The &lt;code>CONFIGURE_DEPENDS&lt;/code> flag was added in CMake 3.12, and thanks to it, the list of files will be automatically re-generated every time we add a new file to the project. The command will work without it, but then you would have to manually regenerate CMake project after adding new files.&lt;/li>
&lt;li>&lt;code>include_directories&lt;/code> tells the toolchain where to look for header files.&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>PROJECT_SOURCE_FILES&lt;/code> variable should have a list of all of our code files, and we&amp;rsquo;ll pass it to &lt;code>add_executable&lt;/code> instead of adding a new file manually.
Of course, this variable can be called anyhow you want - it&amp;rsquo;s not a special name or anything.&lt;/p>
&lt;p>Now, let&amp;rsquo;s configure our project again (VSCode should do this automatically, but i wanna show you how to do it in case it doesn&amp;rsquo;t). Right-click on &lt;code>CMakeLists.txt&lt;/code> and select &amp;ldquo;Configure All Projects&amp;rdquo;&lt;/p>
&lt;p>&lt;img alt="cmake-reconfig" src="https://steelph0enix.github.io/img/vscode-cpp-setup/cmakelists-config.png">&lt;/p>
&lt;blockquote>
&lt;p>Sometimes, when something goes wrong and CMake or VSCode starts behaving strange or getting buggy, it&amp;rsquo;s good to clean up and reconfigure the project (&amp;ldquo;Clean Reconfigure All Projects&amp;rdquo; and &amp;ldquo;Clean Rebuild All Projects&amp;rdquo;). This can sometimes happen when playing with CMakeLists.&lt;/p>
&lt;/blockquote>
&lt;p>Let&amp;rsquo;s add some code to our &lt;code>main.cpp&lt;/code> (or &lt;code>main.c&lt;/code>) to test if additional files are added properly to our project:&lt;/p>
&lt;p>C++ version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.hpp&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, world&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f(&lt;span style="color:#ae81ff">42&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;lib.h&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, world!&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#ae81ff">42&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we should be able to build our program&lt;/p>
&lt;p>&lt;img alt="lib-build" src="https://steelph0enix.github.io/img/vscode-cpp-setup/lib-build.png">&lt;/p>
&lt;p>And run it&lt;/p>
&lt;p>&lt;img alt="lib-run" src="https://steelph0enix.github.io/img/vscode-cpp-setup/lib-run.png">&lt;/p>
&lt;p>At this point, everything should work automatically. You should be able to add new source files to &lt;code>src&lt;/code> dir, and new headers to &lt;code>include&lt;/code>, and CMake should handle them without having to touch &lt;code>CMakeLists.txt&lt;/code> manually. Adding new directories with source/include files is done the same way - just &lt;code>file&lt;/code> the source files, add include path with &lt;code>include_directories&lt;/code> and voila.&lt;/p>
&lt;h3 id="debugging-our-code">Debugging our code&lt;/h3>
&lt;p>Time for a last step in our setup - using a debugger. Fortunately, CMake integration does most of the work for us here.&lt;/p>
&lt;p>Let&amp;rsquo;s add a breakpoint in the first line of our &lt;code>main&lt;/code> function - click on the left of line number, you should see a red dot:&lt;/p>
&lt;p>&lt;img alt="vsc-breakpoint" src="https://steelph0enix.github.io/img/vscode-cpp-setup/vsc-breakpoint.png">&lt;/p>
&lt;p>And start a debugging session by pressing a little bug icon on the bottom of VSCode window, or by using &lt;code>CMake: Debug&lt;/code> command&lt;/p>
&lt;p>&lt;img alt="vsc-debug-cmd" src="https://steelph0enix.github.io/img/vscode-cpp-setup/vsc-debug-icon.png">&lt;/p>
&lt;p>&lt;img alt="vsc-debug-icon" src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-debug.png">&lt;/p>
&lt;p>VSCode should now switch into debugging perspective and program should stop at breakpoint.&lt;/p>
&lt;p>&lt;img alt="vsc-debug-perspective" src="https://steelph0enix.github.io/img/vscode-cpp-setup/vscode-debug-perspective.png">&lt;/p>
&lt;p>And that&amp;rsquo;s basically it. Don&amp;rsquo;t worry about lack of configuration for run/debug in VSCode - CMake integration does everything for us, so there&amp;rsquo;s no need to make them. Just make sure you run/debug the program via CMake commands in VSCode, instead of it&amp;rsquo;s own. Setting up the run/debug configs manually can be pretty annoying at the times, so that&amp;rsquo;s a subject for another guide.&lt;/p>
&lt;p>There&amp;rsquo;s one subject i haven&amp;rsquo;t touched yet, and it&amp;rsquo;s adding external libraries. Since this guide is already long enough, i&amp;rsquo;ll make another one for that.
Now, it&amp;rsquo;s the time for some bonus content.&lt;/p>
&lt;h2 id="bonus-clangd-setup">Bonus: clangd setup&lt;/h2>
&lt;p>&lt;code>clangd&lt;/code> is a language server for C++. It provides functionalities like code completion, code linting (showing warning and errors in real-time), simple refactoring, and so on. There is a C++ language server in VSCode already, as we installed &lt;code>C/C++&lt;/code> extension, but &lt;code>clangd&lt;/code> is better in some ways, and it&amp;rsquo;s more multi-platform (default VSCode C++ language server doesn&amp;rsquo;t work on ARM yet, so if you wanna code on RaspberryPi via SSH - &lt;code>clangd&lt;/code> is your best friend).&lt;/p>
&lt;p>&lt;img alt="clangd-plugin" src="https://steelph0enix.github.io/img/vscode-cpp-setup/ext-clang.png">&lt;/p>
&lt;p>In order to work, &lt;code>clangd&lt;/code> requires &lt;code>compile_commands.json&lt;/code> file to know how your code is compiled and with what flags. Fortunately for us, CMake generates that file automatically, so no further configuration is required on our side!&lt;/p>
&lt;p>Right after the plugin installation, you should see a popup like this one:&lt;/p>
&lt;p>&lt;img alt="clangd-install" src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-install.png">&lt;/p>
&lt;p>In order for &lt;code>clangd&lt;/code> to work, you have to disable the default Intellisense server (press &lt;code>Disable IntelliSense&lt;/code>), and download &lt;code>clangd&lt;/code> binary (which VSCode does for us). After it&amp;rsquo;s downloaded, you should see this popup:&lt;/p>
&lt;p>&lt;img alt="clangd-installed" src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-installed.png">&lt;/p>
&lt;p>Reload the window, open up a C/C++ source file, and check if &lt;code>clangd&lt;/code> info is displayed on the bottom of the screen&lt;/p>
&lt;p>&lt;img alt="clangd-idle" src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-idle.png">&lt;/p>
&lt;p>If that&amp;rsquo;s the case, congratulations, it should work now. Check if there&amp;rsquo;s no &lt;code>include&lt;/code> errors, and if the autocompletion works (you can manually trigger autocompletion with &lt;code>Ctrl+Space&lt;/code> shortcut). There should also be a &lt;code>.cache&lt;/code> directory in your project folder now, with &lt;code>clangd&lt;/code>&amp;rsquo;s cache files - make sure to add it to &lt;code>.gitignore&lt;/code> before making a commit :P&lt;/p>
&lt;p>&lt;img alt="clangd-cache" src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-cache.png">&lt;/p>
&lt;p>Full list of &lt;code>clangd&lt;/code> features can be found here: &lt;a href="https://clangd.llvm.org/features.html">https://clangd.llvm.org/features.html&lt;/a>. I strongly recommend checking it out.&lt;/p>
&lt;h3 id="clang-format-setup">Clang-Format setup&lt;/h3>
&lt;p>&lt;code>clangd&lt;/code> embeds &lt;code>clang-format&lt;/code> support, which is a code formatting tool - one of the best in C and C++ environment. &lt;code>clang-format&lt;/code> allows you to manually or automatically format the code (for example, on-save, format-while-typing is not yet supported with &lt;code>clangd&lt;/code>) according to your preferences, which you can set by creating &lt;code>.clang-format&lt;/code> file in your workspace root, with configuration options for &lt;code>clang-format&lt;/code>.&lt;/p>
&lt;p>The list of configuration options is pretty long and can be found here: &lt;a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">https://clang.llvm.org/docs/ClangFormatStyleOptions.html&lt;/a>. I&amp;rsquo;m not gonna describe them all of course, i&amp;rsquo;ll just show an setup example.&lt;/p>
&lt;p>Let&amp;rsquo;s create a &lt;code>.clang-format&lt;/code> file in our workspace root dir, and put this inside:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-clang-format" data-lang="clang-format">BasedOnStyle: Chromium
IndentWidth: 2
Standard: c++17
BreakBeforeBraces: Linux
&lt;/code>&lt;/pre>&lt;p>&lt;img alt="clang-format" src="https://steelph0enix.github.io/img/vscode-cpp-setup/clang-format.png">&lt;/p>
&lt;p>If &lt;code>clangd&lt;/code> is the only formatter you have installed, it should be treated as default. If not, make sure it is by opening command list (&lt;code>Ctrl+Shift+P&lt;/code>), looking for &lt;code>Format Document With...&lt;/code> option, and setting default formatter to &lt;code>clangd&lt;/code>.&lt;/p>
&lt;p>Now, open a &lt;code>main&lt;/code> file and either right-click and pick &lt;code>Format document&lt;/code> option, or use a shortcut (&lt;code>Shift+Alt+F&lt;/code> on Windows by default). The code should now look like this:&lt;/p>
&lt;p>&lt;img alt="main-formatted" src="https://steelph0enix.github.io/img/vscode-cpp-setup/main-formatted.png">&lt;/p>
&lt;p>If it had been formatted differently, check the &lt;code>clangd&lt;/code> output in VSCode window. All the issues and errors with &lt;code>.clang-format&lt;/code> file should be there.&lt;/p>
&lt;p>&lt;img alt="clangd-output" src="https://steelph0enix.github.io/img/vscode-cpp-setup/clangd-output.png">&lt;/p>
&lt;p>You can set autoformatting in VSCode settings - open settings window with &lt;code>Ctrl+,&lt;/code> or &lt;code>File -&amp;gt; Preferences -&amp;gt; Settings&lt;/code>, and look for &lt;code>format on&lt;/code> options&lt;/p>
&lt;p>&lt;img alt="vsc-format-on" src="https://steelph0enix.github.io/img/vscode-cpp-setup/vsc-format-settings.png">&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>And that would be it. I hope it&amp;rsquo;s not too long.&lt;/p>
&lt;p>If there are any issues or questions about the guide itself or the setup process, feel free to &lt;a href="https://steelph0enix.github.io/about/">contact me&lt;/a>!&lt;/p></content></item></channel></rss>